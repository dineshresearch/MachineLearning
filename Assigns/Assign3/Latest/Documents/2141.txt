Generics in Java
Generics are a facility of generic programming that was added to the Java programming language in 2004 as part of J2SE 5.0. They allow "a type or method to operate on objects of various types while providing compile-time type safety."[1]

As per JavaTM Language Specification[2]:

The following block of Java code illustrates a problem that exists when not using generics. First, it declares an ArrayList of type Object. Then, it adds a String to the ArrayList. Finally, it attempts to retrieve the added String and cast it to an Integer.
Although the code compiles without error, it throws a runtime exception (java.lang.ClassCastException) when executing the third line of code. This type of problem can be avoided by using generics and is the primary motivation for using generics.
Utilizing generics, the above code fragment can be rewritten as follows:
The type parameter String within the angle brackets declares the ArrayList to be constituted of Strings (a descendant of the ArrayList's generic Object constituents). With generics, it is no longer necessary to cast the third line to any particular type, because the result of v.get(0) is defined as String by the code generated by the compiler.
Compiling the third line of this fragment with J2SE 5.0 (or later) will yield a compile-time error because the compiler will detect that v.get(0) returns String instead of Integer. For a more elaborate example, see [3].

Generic type parameters in Java are not limited to specific classes. Java allows the use of wildcards to specify bounds on the type of parameters a given generic object may have. Wildcards are type parameters of the form "?", possibly annotated with a bound. Given that the exact element type of an object with a wildcard is unknown, restrictions are placed on the type of methods that may be called on the object.
As an example of an unbounded wildcard, List<?> indicates a list which has an unknown object type. Methods which take such a list as an argument can take any type of list, regardless of parameter type. Reading from the list will return objects of type Object, and writing non-null elements to the list is not allowed, since the parameter type is not known.
To specify the upper bound of a generic element, the extends keyword is used, which indicates that the generic type is a subtype of the bounding class. Thus it must either extend the class, or implement the interface of the bounding class. So List<? extends Number> means that the given list contains objects of some unknown type which extends the Number class. For example, the list could be List<Float> or List<Number>. Reading an element from the list will return a Number, while writing non-null elements is once again not allowed.
The use of wildcards above are necessary since objects of one type parameter cannot be converted to objects of another parameter. Neither List<Number> nor List<Float> is a subtype of the other (even though Float is a subtype of Number). So, code that deals with List<Number> does not work with List<Float>. (If it did, it would be possible to insert a Number that is not a Float into it, which violates type safety.) The solution with wildcards works because it disallows operations that would violate type safety.
To specify the lower bounding class of a generic element, the super keyword is used. This keyword indicates that the aforementioned generic type is a super-type of said bounding class. So, List<? super Number> could represent List<Number> or List<Object>. Reading from a list defined as List<? super Number> returns elements of type Object. Writing to such a list requires elements of type Number or its subclasses.

Here is an example of a generic class:
This generic class can be used in the following way:

Here is an example of a generic method using the generic class above:
In many cases the user of the method need not indicate the type parameters, as they can be inferred:
The parameters can be explicitly added if needed:

Although exceptions themselves cannot be generic, generic parameters can appear in a throws clause:

Generics are checked at compile-time for type correctness. The generic type information is then removed via a process called type erasure. For example, List<Integer> will be converted to the raw type (non-generic type) List, which can contain arbitrary objects. However, due to the compile-time check, the resulting code is guaranteed to be type correct, as long as the code generated no unchecked compiler warnings.
As a result, there is no way to tell at runtime which type parameter is used on an object. For example, when you examine an ArrayList at runtime, there is no general way to tell whether it was an ArrayList<Integer> or an ArrayList<Float>. (There are partial approaches — for example, individual elements may be examined to see what type they belong to, since an ArrayList<Float> should never contain an Integer and vice versa; and it can be determined using reflection if the ArrayList actually belongs to a non-parameterized subtype of a specific ArrayList type, such as an ArrayListOfFloats that's declared to extend ArrayList<Float> — but no approach will work in all cases.)
The following code demonstrates that the Class objects appear the same:
Java generics differ from C++ templates. Java generics generate only one compiled version of a generic class or function regardless of the number of types used. Furthermore, the Java run-time environment does not need to know which parameterized type is used because the type information is validated at compile-time and erased from the compiled code. Consequently, one cannot instantiate a Java class of a parameterized type because instantiation requires a call to a constructor, which is not possible when the type is unknown at both compile-time and runtime.
Because there is only one copy of a generic class, static variables are shared among all the instances of the class, regardless of their type parameter. As a result, the type parameter cannot be used in the declaration of static variables or in static methods. Static variables and static methods are "outside" of the scope of the class's parameterized types.



