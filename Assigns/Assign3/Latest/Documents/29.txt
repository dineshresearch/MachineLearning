JRuby
JRuby is a Java implementation of the Ruby programming language, being developed by the JRuby team.
JRuby is free software released under a three-way CPL/GPL/LGPL license.
JRuby is tightly integrated with Java to allow the embedding of the interpreter into any Java application with full two-way access between the Java and the Ruby code (compare Jython for the Python language).
JRuby's lead developers are Charles Nutter [1], Thomas Enebo [2] Ola Bini [3] and Nick Sieger [4]. In September 2006, Sun Microsystems hired Enebo and Nutter to work on JRuby full time.[1] In June 2007, ThoughtWorks hired Ola Bini to work on Ruby and JRuby.[2]

JRuby was originally created by Jan Arne Petersen, in 2001. At that time and for several years following, the code was a direct port of the Ruby 1.6 C code. With the release of Ruby 1.8.6, an effort began to update JRuby to 1.8.6 features and semantics. Since 2001, several contributors have assisted the project, leading to the current (2008) core team of four members.
The Netbeans Ruby Pack, available since NetBeans 6.0, allows IDE development with Ruby and JRuby, as well as Ruby on Rails for the two implementations of Ruby [5] [6].
JRuby 1.1 added Just-in-time compilation and Ahead-of-time compilation modes to JRuby and was already faster in most cases than the current Ruby 1.8.7 reference implementation[3][4].
JRuby 1.1.1 is stated to be packaged in Fedora 9[5][6].
Since version 1.1.1, the JRuby team began to issue point releases often to quickly address issues that are brought up by users[7].
JRuby support Ruby MRI 1.8.6, and work is ongoing to add a Ruby 1.9 support, but as Ruby 1.8.7 is mainly a transitional version to 1.9, it will not be supported[8].

JRuby supports Ruby on Rails since version 0.9 (May 2006) [9][10], with the ability to execute RubyGems and WEBrick. Since the hiring of the two lead developers by Sun, Rails compatibility and speed have improved greatly. JRuby version 1.0 successfully passed nearly all of Rails' own test cases[11]. Since then, developers have begun to use JRuby for Rails applications in production environments [12].

On February 27, 2008, Sun Microsystems and the University of Tokyo announced a joint-research project to implement a Virtual Machine capable of executing more than one Ruby or JRuby application on one interpreter[13].

JSR 292 (Supporting Dynamically Typed Languages on the JavaTM Platform) [14] propose to:
The Sun Open source project Multi Language Virtual Machine aim to prototype this JSR[15]. The first working prototype, developed as a patch on OpenJDK, was announced and made available on end of August 2008[16][17].
The JRuby team has successfully wired dynamic invocation in their codebase, albeit in a very primitive way. Dynamic invocation shipped with the 1.1.5 release, although being disabled on JVMs without Dynamic invocation capabilities[18].

This table present only releases that present significant steps in JRuby history, aside from versions that mainly fixed bugs and improved performance.

Since early 2006, the current JRuby core team has endeavored to move JRuby beyond being a simple C port, to support better performance and to aid eventual compilation to Java bytecode. To support this end, the team set an ambitious goal: to be able to run Ruby on Rails unmodified using JRuby. In the process of achieving this goal, the JRuby test suite expanded to such extent that the team gained confidence in the "correctness" of JRuby. As a result, toward the end of 2006 and in the beginning of 2007, they began to commit much more complicated redesigns and refactorings of JRuby's core subsystems.
JRuby is designed to work as a mixed-mode virtual machine for Ruby, where code can be either interpreted directly, just-in-time compiled at runtime to Java bytecode, or ahead-of-time compiled to Java bytecode before execution. Until October 2007, only the interpreted mode supported all Ruby's constructs, but a full AOT/JIT compiler is available since version 1.1[19]. The compiler design allows for interpreted and compiled code to run side-by-side, as well as decompilation to reoptimize and outputting generated bytecode as Java class files.


JRuby is essentially the Ruby interpreter, except this version is written entirely in Java. JRuby features some of the same concepts, including object-oriented programming, and duck-typing as Ruby. The key difference is that JRuby is tightly integrated with Java, and can be called directly from Java programs[22].

One powerful feature of JRuby is its ability to invoke the classes of the Java Platform. To do this, one must first load JRuby's Java support, by calling "include Java" ("require 'java'" in earlier versions). The following example creates a Java JFrame with a JLabel:
JRuby also allows the user to call Java code using the more Ruby-like underscore method naming and to refer to JavaBean properties as attributes:

JRuby can just as easily be called from Java, using either the JSR 223[23] Scripting for Java 6 or the Apache Bean Scripting framework. More information on this is available in the JRuby Wiki article.

JRuby supports interpreted mode, AOT mode, and JIT mode (the last two modes are available since version 1.1[19]). JRuby evolved from being several times slower than Ruby Reference implementation[24], to being several times faster[25]

In this mode, JRuby 1.0 was slower than the C Ruby reference[26]. For example, serving up Rails requests in the standard interpreted mode, JRuby was 50% to 70% slower than C Ruby 1.8. Since then, JRuby performance in interpreted mode has improved a lot. The JRuby team claims that JRuby 1.4 is 15%-20% faster in interpreted mode than Ruby MRI [27].
When using Ruby 1.9 (YARV) benchmarks on Java 6, interpreted JRuby 1.0 was 4 times slower than Ruby (including startup time).

JIT mode is available since JRuby 1.1. In performance benchmarks, JRuby is consistently 200% to 300% faster than C Ruby 1.8.6 [25] but still 15%-25% slower than C Ruby 1.9. However, the JRuby 1.1.6 version outperforms C Ruby 1.9 in some cases [28][29].
Also in a real Mongrel web server application, JRuby performance is better than Ruby (after the Virtual Machine has instantiated)[30].


