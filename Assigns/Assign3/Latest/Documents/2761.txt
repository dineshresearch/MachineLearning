Procedural generation
Procedural generation is a widely used term in the production of media, indicating the possibility to create content on the fly rather than prior to distribution. This is often related to computer graphics applications and video game level design.

The term procedural refers to the process that computes a particular function. Fractals, an example of procedural generation, dramatically expresses this concept, around which a whole body of mathematics—fractal geometry—has evolved. Commonplace procedural content includes textures and meshes. Sound is often procedurally generated as well and has applications in both speech synthesis as well as music. It has been used to create compositions in various genres of electronic music by artists such as Brian Eno who popularized the term "generative music".[1]
While software developers have applied procedural generation techniques for years, few products have employed this approach extensively. An exception is Will Wright's Spore, a recently released video game entirely populated with procedurally generated content. Procedurally generated elements have also appeared in earlier video games: The Elder Scrolls II: Daggerfall randomly generates terrain and NPCs, creating a world roughly the actual size of the British Isles. Soldier of Fortune from Raven Software uses simple routines to detail enemy models. It could also be said that the lighting in Doom 3 from id Software is procedurally generated because it does not rely on lightmaps precomputed with a radiosity process[citation needed]. More recently Avalanche Studios employed procedural generation to create a large and varied group of tropical islands in great detail for Just Cause.
The modern demoscene uses procedural generation to package a great deal of audiovisual content into relatively small programs. Farbrausch is a team famous for such achievements, although many similar techniques were already implemented by The Black Lotus in the 1990s.

Procedurally generated content such as textures and landscapes may exhibit variation, but the generation of a particular item or landscape must be identical from frame to frame. Accordingly, the functions used must be referentially transparent, always returning the same result for the same point, so that they may be called in any order and their results freely cached as necessary. This is similar to lazy evaluation in functional programming languages.

The earliest computer games were severely limited by memory constraints. This forced content like maps to be generated algorithmically on the fly: there simply wasn't enough space to store a large amount of pre-made levels and artwork. Pseudorandom number generators were often used with predefined seed values in order to create very large game worlds that appeared premade. For example, The Sentinel supposedly had 10,000 different levels stored in only 48 or 64 kilobytes. An extreme case was Elite, which was originally planned to contain a total of 248 (approximately 282 trillion) galaxies with 256 solar systems each. The publisher, however, was afraid that such a gigantic universe would cause disbelief in players, and eight of these galaxies were chosen for the final version.[2] Other notable early examples include the 1985 game Rescue on Fractalus that used fractal technology to procedurally create in real time the craggy mountains of an alien planet and River Raid, the 1982 Activision game that used a pseudorandom number sequence generated by a linear feedback shift register in order to generate a scrolling maze of obstacles.
Today, most games include thousands of times as much data in terms of memory as algorithmic mechanics. For example, all of the buildings in the large game worlds of the Grand Theft Auto games have been individually designed and placed by artists. In a typical modern video game, game content such as textures and character and environment models are created by artists beforehand, then rendered in the game engine. As the technical capabilities of computers and video game consoles increases, the amount of work required by artists also greatly increases. First, high-end gaming PCs and current-generation game consoles like the Xbox 360 and PlayStation 3 are capable of rendering scenes containing many very detailed objects with high-resolution textures in high-definition. This means that artists must invest a great deal more time in creating a single character, vehicle, building, or texture, since gamers will tend to expect ever-increasingly detailed environments.
Furthermore, the number of unique objects displayed in a video game is increasing. In addition to highly detailed models, players expect a variety of models that appear substantially different from one another. In older games, a single character or object model might have been used over and over again throughout a game. With the increased visual fidelity of modern games, however, it is very jarring (and threatens the suspension of disbelief) to see many copies of a single object, while the real world contains far more variety. Again, artists would be required to complete exponentially more work in order to create many different varieties of a particular object. The need to hire larger art staffs is one of the reasons for the rapid increase in game development costs. Some initial approaches to procedural synthesis attempted to solve these problems by shifting the burden of content generation from the artists to programmers who can create code which automatically generates different meshes according to input parameters. Although sometimes this still happens, what has been recognized is that applying a purely procedural model is often hard at best, requiring huge amounts of time to evolve into a functional, usable and realistic-looking method. Instead of writing a procedure that completely builds content procedurally, it has been proven to be much cheaper and more effective to rely on artist created content for some details. For example, SpeedTree is middleware used to generate a large variety of trees procedurally, yet its leaf textures can be fetched from regular files, often representing digitally acquired real foliage. Other effective methods to generate hybrid content are to procedurally merge different pre-made assets or to procedurally apply some distortions to them.
Supposing, however, a single algorithm can be envisioned to generate a realistic-looking tree, the algorithm could be called to generate random trees, thus filling a whole forest at runtime, instead of storing all the vertices required by the various models. This would save storage media space and reduce the burden on artists, while providing a richer experience. The same method would require far more processing power. Since CPUs are constantly increasing in speed, however, the latter is becoming less of a hurdle.
A different problem is that it is not easy to develop a good algorithm for a single tree, let alone for a variety of species (compare Sumac, Birch, Maple). An additional caveat is that assembling a realistic-looking forest could not be done by simply assembling trees because in the real world there are interactions between the various trees which can dramatically change their appearance and distribution.
In 2004, a PC first-person shooter called .kkrieger was released that made heavy use of procedural synthesis: while quite short and very simple, the advanced video effects were packed into just 96 Kilobytes. In contrast, many modern games are released across several CDs, often exceeding 2 gigabytes in size, more than 20,000 times larger. Naked Sky's RoboBlitz used procedural generation to maximize content in a less than 50MB downloadable file for Xbox Live Arcade. Will Wright's Spore also makes use of procedural synthesis.

As in video games, procedural generation is often used in film to rapidly create visually interesting and accurate spaces. This comes in a wide variety of applications.
One application is known as an "imperfect factory," where artists can rapidly generate a large number of similar objects. This accounts for the fact that, in real life, no two objects are ever exactly alike. For instance, an artist could model a product for a grocery store shelf, and then create an imperfect factory that would generate a large number of similar objects to populate the shelf.
Noise is extremely important to procedural workflow in film, the most prolific of which is Perlin noise. Noise refers to an algorithm that generates a patterned sequence of pseudorandom numbers.

Simple programs which generate complex output are a typical method of procedural generation. Typically, one starts with some simple initial conditions like an array of numbers. Then one applies simple rules to the array, which determine the next step in the evolution of the output - that is, the next array of numbers. The rules can be fixed, or they can be changing in time. One can let the program run, and given the right update rules and initial conditions, one can obtain a non-repeating evolution starting from an initial array.
Cellular automata are discrete computer models of evolutionary behavior which start from an array of differently-colored cells, then apply update rules to determine the colors of the next array of cells. Typically one starts with a two-color program, and a random finite array of black and white cells. Then one defines a neighborhood --- for the simplest case, just the two neighboring cells of any one cell ---- and creates a so-called "update rule" to determine what the next cell in the evolution will be. Typical elementary update rules are of the form, "If the current cell is black and the cells to the right and left are white, then the next cell in the evolution shall be white."
It is an astonishing fact that such simple rules, even in the simplest case of two colors, can produce a complex evolution. But, in fact, they can (see Rule 30 and Rule 110).
For game developers, this means that, using with finite initial conditions and extremely simple rules, one can generate complex behavior. That is, content can be nearly spontaneously generated from virtually nothing, which is the idea behind procedural generation. Evolving cellular automata is one way of generating a large amount of content from a small amount of input.












