Motorola 68000
The Motorola 68000 is a 16/32-bit [1] CISC microprocessor core designed and marketed by Freescale Semiconductor (formerly Motorola Semiconductor Products Sector). Introduced in 1979 as the first member of the successful 32-bit m68k family of microprocessors, it is generally software forward compatible with the rest of the line despite being limited to a 16-bit wide external bus. After three decades in production, the 68000 architecture is still in use.

The 68000 grew out of the MACSS (Motorola Advanced Computer System on Silicon) project, begun in 1976 to develop an entirely new architecture without backward compatibility. It would be a higher-power sibling complementing the existing 8-bit 6800 line rather than a compatible successor. In the end, the 68000 did retain a bus protocol compatibility mode for existing 6800 peripheral devices, and a version with an 8-bit data bus was produced. However, the designers mainly focused on the future, or forward compatibility, which gave the M68K platform a head start against later 32-bit instruction set architectures. For instance, the CPU registers are 32 bits wide, though few self-contained structures in the processor itself operate on 32 bits at a time. The MACSS team drew heavily on the influence of minicomputer processor design, such as the PDP-11 and VAX systems, which were similarly microcoded.
In the mid 1970s, the 8-bit processor manufacturers raced to introduce the 16-bit generation. National Semiconductor had been first with its IMP-16 and PACE processors in 1973-1975, but these had issues with speed. The Intel 8086 in 1977 quickly gained popularity. The decision to leapfrog the competition and introduce a hybrid 16/32-bit design was necessary, and Motorola turned it into a coherent mission. Arriving late to the 16-bit arena afforded the new processor more transistors (roughly 40000 active versus 20000 active in the 8086), 32-bit macroinstructions, and acclaimed general ease of use.
The original MC68000 was fabricated using an HMOS process with a 3.5-micrometre (3500 nanometre) feature size. Initial engineering samples were released in late 1979. Production chips were available in 1980, with initial speed grades of 4, 6, and 8 MHz. 10 MHz chips became available during 1981, and 12.5 MHz chips during 1982. The 16.67 MHz "12F" version of the MC68000, the fastest version of the original HMOS chip, was not produced until the late 1980s.
The 68000 had many high-end design wins early on. It became the dominant CPU for Unix based workstations including Sun workstations and Apollo/Domain workstations, found its way into heralded computers such as the Amiga, Atari ST, Apple Lisa and Macintosh, and was used in the first generation of desktop laser printers including the original Apple Inc. LaserWriter. In 1982, the 68000 received an update to its ISA allowing it to support virtual memory and to conform to the Popek and Goldberg virtualization requirements. The updated chip was called the 68010. A further extended version which exposed 31 bits of the address bus was also produced, in small quantities, as the 68012.
To support lower-cost systems and control applications with smaller memory sizes, Motorola introduced the 8-bit compatible MC68008, also in 1982. This was a 68000 with an 8-bit data bus and a smaller (20 bit) address bus. After 1982, Motorola devoted more attention to the 68020 and 88000 projects.

The 68HC000, the CMOS version of the 68000, was designed by Hitachi and jointly introduced in 1985.[2] Motorola's version was called the MC68HC000, while Hitachi's was the HD68HC000. The 68HC000 was eventually offered at speeds from 8 MHz to 20 MHz. Except for using CMOS circuitry, it behaved identically to the HMOS MC68000, but the change to CMOS greatly reduced its power consumption. The original HMOS MC68000 consumed around 1.35 watts at an ambient temperature of 25 Â°C, regardless of clock speed, while the MC68HC000 consumed only 0.13 watts at 8 MHz and 0.38 watts at 20 MHz. (Unlike CMOS circuits, HMOS still draws power when idle, so power consumption varies little with clock rate.) Motorola replaced the MC68008 with the MC68HC001 in 1990.[3] This chip resembled the 68HC000 in most respects, but its data bus could operate in either 16-bit or 8-bit mode, depending on the value of an input pin at reset. Thus, like the 68008, it could be used in systems with cheaper 8-bit memories.
Several other companies were second-source manufacturers of the HMOS 68000. These included Hitachi (HD68000), Mostek (MK68000), Rockwell (R68000), Signetics (SCN68000), Thomson/SGS-Thomson (originally EF68000 and later TS68000), and Toshiba (TMP68000). Toshiba was also a second-source maker of the CMOS 68HC000 (TMP68HC000).

After being succeeded by "true" 32-bit microprocessors, the 68000 was used as the core of many microcontrollers. In 1989, Motorola introduced the MC68302 communications processor,[4]. In 1991 Motorola introduced a separate processor chip based on this core, the MC68EC000.[5] In 1996 Motorola introduced this static core as a separate processor, the MC68SEC000.[6]
Motorola ceased production of the HMOS MC68000 and MC68008 in 1996,[7] but its spin-off company, Freescale Semiconductor, is still producing the MC68HC000, MC68HC001, MC68EC000, and MC68SEC000, as well as the MC68302 and MC68306 microcontrollers and later versions of the DragonBall family. The 68000's architectural descendants, the 680x0, CPU32, and Coldfire families, are also still in production.

The 68000 was first used during the early 1980s in high-priced systems, including multiuser microcomputers like the WICAT 150 [1], early Alpha Microsystems computers, Tandy TRS-80 Model 16, and Fortune 32:16; single-user workstations such as Hewlett-Packard's HP 9000 Series 200 systems, the first Apollo/Domain systems, Sun Microsystems' Sun-1, and the Corvus Concept; and graphics terminals like Digital Equipment Corporation's VAXstation 100 and Silicon Graphics' IRIS 1000 and 1200. Unix systems rapidly moved to the more capable later generations of the 68k line, which remained popular in that market throughout the 1980s.
During the mid 1980s, the 68000 was first used in personal and home computers, starting with the Apple Lisa and Macintosh, and followed by the Commodore Amiga, Atari ST, and Sharp X68000. The 68008, on the other hand, was only used in one home computer system, the Sinclair QL (though the QL was a sister machine to the ICL One Per Desk, which also used a 68008).
The 68000 eventually saw great success as a controller. As early as 1981, laser printers such as the Imagen Imprint-10 were driven by external controllers using the 68000 as the CPU. The first HP LaserJet, introduced in 1984, used an 8 MHz 68000 in its built-in controller. Similar 68000-based integrated controllers were subsequently used in many other laser printers, including the Apple LaserWriter, the first PostScript laser printer, introduced in 1985. The 68000 continued to be widely used in laser printers throughout the rest of the 1980s, persisting well into the 1990s in low-end printers.
Outside traditional commercial or domestic computing applications, the 68000 also saw success in the field of industrial control systems. Among the systems which benefited from having a 68000 or derivative as their microprocessor were families of Programmable Logic Controllers (PLCs) manufactured by Allen-Bradley, Texas Instruments and subsequently, following the acquisition of that division of TI, by Siemens. Users of such systems do not accept product obsolescence at the same rate as domestic users and it is entirely likely that despite having been installed over 20 years ago, many 68000-based controllers will continue in reliable service well into the 21st century.
As technological advances obsoleted the 68000 from use in the standalone computing market, its use grew in consumer and embedded applications. Video game manufacturers used the 68000 as the backbone of many arcade games and home game consoles. Atari's Food Fight, from 1983, was one of the first 68000-based arcade games. The 68000 was the main CPU of many arcade systems during the late 1980s and early 1990s, such as Sega's System 16, Capcom's CPS-1 and CPS-2, and SNK's Neo Geo. A number of arcade systems used two 68000s (such as OutRun); some even used three. During the 1990s, as arcade systems switched to more powerful processors for the main CPU, they often continued to use the 68000 as a sound controller.
The 68000 was also the central processor in several home game consoles of the late 1980s/early 1990s, including the Sega Mega Drive (Sega Genesis), the Sega Mega-CD (Sega CD) (an add on for the Mega Drive/Genesis, making a system with two 68000s), and the console version of the Neo Geo. Some later game consoles still included the 68000: the Sega Saturn used it as a dedicated sound controller, and in the Atari Jaguar it co-ordinated the activities of the other specialized graphics and sound chips.
The 68000-based 683XX microcontrollers have been utilized in a wide variety of applications, including networking and telephone equipment, television set-top boxes, and laboratory and medical instruments, among others. The MC68302 and its derivatives have been used in many communication products from Cisco, 3com, Ascend, Marconi, Cyclades and others. The DragonBall family was used in Palm Computing's popular Palm PDAs and in the Handspring Visor series, until Palm gradually phased out the architecture in favor of ARM processors. AlphaSmart uses the DragonBall family in later versions of its portable word processors.
Texas Instruments uses the 68000 in its high-end graphing calculators, the TI-89 and TI-92 series and Voyage 200. Early versions of these used a specialized microcontroller with a static 68EC000 core; later versions use a standard MC68SEC000 processor.


The 68000 had an 23-bit external address bus and two byte-select signals "replaced" A0. These 25-lines could therefore reach 16 MB of physical memory with byte resolution. Address storage and computation used 32 bits, however, with the high-order byte ignored due to the physical lack of pins. This allowed it to run software written for a flat 32-bit address space. By modern definition this meant that the 68000 was a 32-bit microprocessor. Motorola's intent with the internal 32-bit address space was forwards compatibility, making it feasible to write 68000 software that would take full advantage of later 32-bit implementations of the 68000 instruction set.
However, this did not prevent programmers from writing forward incompatible software. "24-bit" software that discarded the upper address byte, or used it for purposes other than addressing, could fail on 32-bit 68K implementations.

The CPU had eight 32-bit general-purpose data registers (D0-D7), and eight address registers (A0-A7). The last address register was also the standard stack pointer, and could be called either A7 or SP. This was a good number of registers in many ways. It was small enough to allow the 68000 to respond quickly to interrupts (because only 15 or 16 had to be saved), and yet large enough to make most calculations fast.
Having two types of registers was mildly annoying at times, but not hard to use in practice. Reportedly, it allowed the CPU designers to achieve a higher degree of parallelism, by using an auxiliary execution unit for the address registers.
Integer representation in the 68000 family is big-endian.

The 68000 comparison, arithmetic and logic operations set bit flags in a status register to record their results for use by later conditional jumps. The bit flags were "zero" (Z), "carry" (C), "overflow" (V), "extend" (X), and "negative" (N). The "extend" (X) flag deserves special mention, because it was separated from the carry flag. This permitted the extra bit from arithmetic, logic, and shift operations to be separated for the carry for flow-of-control and linkage.

The designers attempted to make the assembly language orthogonal. That is, instructions were divided into operations and address modes, and almost all address modes were available for almost all instructions. Many programmers disliked the "near" orthogonality, while others were grateful for the attempt.
At the bit level, the person writing the assembler would clearly see that these "instructions" could become any of several different op-codes. It was quite a good compromise because it gave almost the same convenience as a truly orthogonal machine, and yet also gave the CPU designers freedom to fill in the op-code table.
With only 56 instructions the minimal instruction size was huge for its day at 16 bits. Furthermore, many instructions and addressing modes added extra words on the back for addresses, more address-mode bits, etc.
Many designers believed that the MC68000 architecture had compact code for its cost, especially when produced by compilers. This belief in more compact code led to many of its design wins, and much of its longevity as an architecture.
This belief (or feature, depending on the designer) continued to make design wins for the instruction set (with updated CPUs) up until the ARM architecture introduced the Thumb instruction set that was similarly compact.

The CPU, and later the whole family, implemented exactly two levels of privilege. User mode gave access to everything except the interrupt level control. Supervisor privilege gave access to everything. An interrupt always became supervisory. The supervisor bit was stored in the status register, and visible to user programs.
A real advantage of this system was that the supervisor level had a separate stack pointer. This permitted a multitasking system to use very small stacks for tasks, because the designers did not have to allocate the memory required to hold the stack frames of a maximum stack-up of interrupts.

The CPU recognized 7 interrupt levels. Levels 1 through 7 were strictly prioritized. That is, a higher-numbered interrupt could always interrupt a lower-numbered interrupt. In the status register, a privileged instruction allowed one to set the current minimum interrupt level, blocking lower priority interrupts. Level 7 was not maskable - in other words, an NMI. Level 1 could be interrupted by any higher level. Level 0 means no interrupt. The level was stored in the status register, and was visible to user-level programs.
Hardware interrupts are signalled to the CPU using three inputs that encode the highest pending interrupt priority. A separate interrupt controller is usually required to encode the interrupts, though for systems that do not require more than three hardware interrupts it is possible to connect the interrupt signals directly to the encoded inputs at the cost of additional software complexity. The interrupt controller can be as simple as a 74LS148 priority encoder, or may be part of a VLSI peripheral chip such as the MC68901 Multi-Function Peripheral, which also provided a UART, timer, and parallel I/O.
The "exception table" (interrupt vector addresses) was fixed at addresses 0 through 1023, permitting 256 32-bit vectors. The first vector was the starting stack address, and the second was the starting code address. Vectors 3 through 15 were used to report various errors: bus error, address error, illegal instruction, zero division, CHK & CHK2 vector, privilege violation, and some reserved vectors that became line 1010 emulator, line 1111 emulator, and hardware breakpoint. Vector 24 started the real interrupts: spurious interrupt (no hardware acknowledgement), and level 1 through level 7 autovectors, then the 15 TRAP vectors, then some more reserved vectors, then the user defined vectors.
Since at a minimum the starting code address vector must always be valid on reset, systems commonly included some nonvolatile memory (e.g. ROM) starting at address zero to contain the vectors and bootstrap code. However, for a general purpose system it is desirable for the operating system to be able to change the vectors at runtime. This was often accomplished by either pointing the vectors in ROM to a jump table in RAM, or through use of bank-switching to allow the ROM to be replaced by RAM at runtime.
The 68000 did not meet the Popek and Goldberg virtualization requirements for full processor virtualization because it had a single unprivileged instruction "MOVE from SR", which allowed user-mode software read-only access to a small amount of privileged state.
The 68000 was also unable to easily support virtual memory, which requires the ability to trap and recover from a failed memory access. The 68000 does provide a bus error exception which can be used to trap, but it does not save enough processor state to resume the faulted instruction once the operating system has handled the exception. Several companies did succeed in making 68000 based Unix workstations with virtual memory that worked, by using two 68000 chips running in parallel on different phased clocks. When the "leading" 68000 encountered a bad memory access, extra hardware would interrupt the "main" 68000 to prevent it from also encountering the bad memory access. This interrupt routine would handle the virtual memory functions and restart the "leading" 68000 in the correct state to continue properly synchronized operation when the "main" 68000 returned from the interrupt.
These problems were fixed in the next major revision of the 68K architecture, with the release of the MC68010. The Bus Error and Address Error exceptions pushed a large amount of internal state onto the supervisor stack in order to facilitate recovery, and the MOVE from SR instruction was made privileged. A new unprivileged "MOVE from CCR" instruction was provided for use in its place by user mode software; an operating system could trap and emulate user-mode MOVE from SR instructions if desired.

The standard addressing modes are:
Note that with (A0)+ and -(A0), the actual increment or decrement value is dependent on the operand size: a byte access increments the address register by 1, a word by 2, and a long by 4.
Plus: access to the status register, and, in later models, other special registers.
Most instructions had dot-letter suffixes, permitting operations to occur on 8-bit bytes (".b"), 16-bit words (".w"), and 32-bit longs (".l").
Most instructions are dyadic, that is, the operation has a source, and a destination, and the destination is changed. Notable instructions were:

The 68EC000 is a microprocessor from Motorola. It is a low-cost version of the Motorola 68000, designed for embedded controller applications. The 68EC000 can have either a 8-bit or 16-bit data bus, switchable at reset.[8]
The processors are available in a variety of speeds including 8 and 16 MHz configurations, producing 2,100 and 4,376 Dhrystones each. These processors have no floating point unit and it is difficult to implement an FPU coprocessor (
