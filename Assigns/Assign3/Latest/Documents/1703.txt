Verilog
In the semiconductor and electronic design industry, Verilog is a hardware description language (HDL) used to model electronic systems. Verilog HDL, not to be confused with VHDL, is most commonly used in the design, verification, and implementation of digital logic chips at the Register transfer level (RTL) level of abstraction. It is also used in the verification of analog and mixed-signal circuits.

Hardware description languages, such as Verilog, differ from software programming languages in several fundamental ways. HDLs add the concept of concurrency, which is parallel execution of multiple statements in explicitly specified threads, propagation of time, and signal dependency (sensitivity). There are two assignment operators, a blocking assignment (=), and a non-blocking (<=) assignment. The non-blocking assignment allows designers to describe a state-machine update without needing to declare and use temporary storage variables. Since these concepts are part of the Verilog's language semantics, designers could quickly write descriptions of large circuits, in a relatively compact and concise form. At the time of Verilog's introduction (1984), Verilog represented a tremendous productivity improvement for circuit designers who were already using graphical schematic-capture, and specially-written software programs to document and simulate electronic circuits.
The designers of Verilog wanted a language with syntax similar to the C programming language, which was already widely used in engineering software development. Verilog is case-sensitive, has a basic preprocessor (though less sophisticated than ANSI C/C++), and equivalent control flow keywords (if/else, for, while, case, etc.), and compatible language operators precedence. Syntactic differences include variable declaration (Verilog requires bit-widths on net/reg types), demarcation of procedural-blocks (begin/end instead of curly braces {}), though there are many other minor differences.
A Verilog design consists of a hierarchy of modules. Modules encapsulate design hierarchy, and communicate with other modules through a set of declared input, output, and bidirectional ports. Internally, a module can contain any combination of the following: net/variable declarations (wire, reg, integer, etc.), concurrent and sequential statement blocks and instances of other modules (sub-hierarchies). Sequential statements are placed inside a begin/end block and executed in sequential order within the block. But the blocks themselves are executed concurrently, qualifying Verilog as a Dataflow language.
Verilog's concept of 'wire' consists of both signal values (4-state: "1, 0, floating, undefined"), and strengths (strong, weak, etc.) This system allows abstract modeling of shared signal-lines, where multiple sources drive a common net. When a wire has multiple drivers, the wire's (readable) value is resolved by a function of the source drivers and their strengths.
A subset of statements in the Verilog language is synthesizable. Verilog modules that conform to a synthsizeable coding-style, known as RTL (register transfer level), can be physically realized by synthesis software. Synthesis-software algorithmically transforms the (abstract) Verilog source into a netlist, a logically-equivalent description consisting only of elementary logic primitives (AND, OR, NOT, flipflops, etc.) that are available in a specific VLSI technology. Further manipulations to the netlist ultimately lead to a circuit fabrication blueprint (such as a photo mask-set for an ASIC), or a bitstream-file for an FPGA)


Verilog was invented by Phil Moorby and Prabhu Goel during the winter of 1983/1984 at Automated Integrated Design Systems (later renamed to Gateway Design Automation in 1985) as a hardware modeling language. Gateway Design Automation was later purchased by Cadence Design Systems in 1990. Cadence now has full proprietary rights to Gateway's Verilog and the Verilog-XL simulator logic simulators.

With the increasing success of VHDL at the time, Cadence decided to make the language available for open standardization. Cadence transferred Verilog into the public domain under the Open Verilog International (OVI) (now known as Accellera) organization. Verilog was later submitted to IEEE and became IEEE Standard 1364-1995, commonly referred to as Verilog-95.
In the same time frame Cadence initiated the creation of Verilog-A to put standards support behind its analog simulator Spectre. Verilog-A was never intended to be a standalone language and is a subset of Verilog-AMS which encompassed Verilog-95.

Extensions to Verilog-95 were submitted back to IEEE to cover the deficiencies that users had found in the original Verilog standard. These extensions became IEEE Standard 1364-2001 known as Verilog-2001.
Verilog-2001 is a significant upgrade from Verilog-95. First, it adds explicit support for (2's complement) signed nets and variables. Previously, code authors had to perform signed-operations using awkward bit-level manipulations (for example, the carry-out bit of a simple 8-bit addition required an explicit description of the boolean-algebra to determine its correct value.) The same function under Verilog-2001 can be more succinctly described by one of the built-in operators: +, -, /, *, >>>. A generate/endgenerate construct (similar to VHDL's generate/endgenerate) allows Verilog-2001 to control instance and statement instantiation through normal decision-operators (case/if/else). Using generate/endgenerate, Verilog-2001 can instantiate an array of instances, with control over the connectivity of the individual instances. File I/O has been improved by several new system-tasks. And finally, a few syntax additions were introduced to improve code-readability (eg. always @*, named-parameter override, C-style function/task/module header declaration.)
Verilog-2001 is the dominant flavor of Verilog supported by the majority of commercial EDA software packages.

Not to be confused with SystemVerilog, Verilog 2005 (IEEE Standard 1364-2005) consists of minor corrections, spec clarifications, and a few new language features (such as the uwire keyword.)
A separate part of the Verilog standard , Verilog-AMS, attempts to integrate analog and mixed signal modelling with traditional Verilog.

SystemVerilog is a superset of Verilog-2005, with many new features and capabilities to aid design-verification and design-modeling.
The advent of High Level Verification languages such as OpenVera, and Verisity's E language encouraged the development of Superlog by Co-Design Automation Inc. Co-Design Automation Inc was later purchased by Synopsys. The foundations of Superlog and Vera were donated to Accellera, which later became the IEEE standard P1800-2005: SystemVerilog.

A hello world program looks like this:
A simple example of two flip-flops follows:
The "<=" operator in verilog is another aspect of its being a hardware description language as opposed to a normal procedural language. This is known as a "non-blocking" assignment. When the simulation runs, all of the signals assigned with a "<=" operator have their assignment scheduled to occur after all statements occurring during the same point in time have executed. After all the statements have been executed for one event, the scheduled assignments are performed. This makes it easier to code behaviours that happen simultaneously.
In the above example, flop1 is assigned flop2, and flop2 is assigned flop1. These statements are executed during the same time event. Since the assignments are coded with the "<=" non-blocking operator, the assignments are scheduled to occur at the end of the event. Until then, all reads to flop1 and flop2 will use the values they had at the beginning of the time event.
This means that the order of the assignments are irrelevant and will produce the same result. flop1 and flop2 will swap values every clock.
The other choice for assignment is an "=" operator and this is known as a blocking assignment. When the "=" operator is used, things occur in the sequence they occur much like a procedural language.
In the above example, if the statements had used the "=" blocking operator instead of "<=", the order of the statements would affect the behaviour: the reset would set flop2 to a 1, and flop1 to a 0. A clock event would then set flop1 to flop2, which is a 1 after the reset. The next statement would be executed subsequently and would set flop2 to flop1, which is now a 1. Rather than swap values every clock, flop1 and flop2 would both become 1 and remain that way.
An example counter circuit follows:
An example of delays:
The always clause above illustrates the other type of method of use, i.e. the always clause executes any time any of the entities in the list change, i.e. the b or e change. When one of these changes, immediately a and b are assigned new values. After a delay of 5 time units, c is assigned the value of b and the value of c ^ e is tucked away in an invisible store. Then after 6 more time units, d is assigned the value that was tucked away.
Signals that are driven from within a process (an initial or always block) must be of type reg. Signals that are driven from outside a process must be of type wire. The keyword reg does not necessarily imply a hardware register.

The definition of constants in Verilog supports the addition of a width parameter. The basic syntax is:
<Width in bits>'<base letter><number>
Examples:

As mentioned previously, there are several basic templates that can be used to represent hardware.
The next interesting structure is a transparent latch; it will pass the input to the output when the gate signal is set for "pass-through", and captures the input and store it upon transition of the gate signal to "hold". The output will remain stable regardless of the input signal while the gate is set to "hold". In the example below the "pass-through" level of the gate would be when the value of the if clause is true, i.e. gate = 1. This is read "if gate is true, the din is fed to latch_out continuously." Once the if clause is false, the last value at latch_out will remain and is independent of the value of din.
The flip-flop is the next significant template; in verilog, the D-flop is the simplest, and it can be modeled as:
The significant thing to notice in the example is the use of the non-blocking assignment. A basic rule of thumb is to use <= when there is a posedge or negedge statement within the always clause.
A variant of the D-flop is one with an asynchronous reset; there is a convention that the reset state will be the first if clause within the statement.
The next variant is including both an asynchronous reset and asynchronous set condition; again the convention comes into play, i.e. the reset term is followed by the set term.
The final basic variant is one that implements a D-flop with a mux feeding its input. The mux has a d-input and feedback from the flop itself. This allows a gated load function.
Looking at the original counter example you can see a combination of the basic asynchronous reset flop and Gated input flop used. The register variable count is set to zero on the rising edge or rst. When rst is 0, the variable count will load new data when cet && cep is true. 
There are two separate ways of declaring a verilog process. These are the always and the initial keywords. The always keyword indicates a free-running process that triggers on the accompanying event-control (@) clause. The initial keyword indicates a process executes exactly once. Both constructs begin execution at simulator time 0, and both execute until the end of the block. Once an always block has reached its end, it is rescheduled (again). It is a common misconception to believe that an initial block will execute before an always block. In fact, it is better to think of the initial-block as a special-case of the always-block, one which terminates after it completes for the first time.
These are the classic uses for these two keywords, but there are two significant additional uses. The most common of these is an always keyword without the @() sensitivity list. It is possible to use always as shown below:
The always keyword acts similar to the "C" construct while(1) {..} in the sense that it will execute forever.
The other interesting exception is the use of the initial keyword with the addition of the forever keyword.
The example below is functionally identical to the always example above.

The fork/join pair are used by Verilog to create parallel processes. All statements (or blocks) between a fork/join pair begin execution simultaneously upon execution flow hitting the fork. Execution continues after the join upon completion of the longest running statement or block between the fork and join.
The way the above is written, it is possible to have either the sequences "ABC" or "BAC" print out. The order of simulation between the first $write and the second $write depends on the simulator implementation. This illustrates one of the biggest issues with Verilog. You can have race conditions where the language execution order doesn't guarantee the results.

The order of execution isn't always guaranteed within verilog. This can best be illustrated by a classic example. Consider the code snippet below:
What will be printed out for the values of a and b? Well - it could be 0 and 0, or perhaps 0 and X! This all depends on the order of execution of the initial blocks. If the simulators scheduler works from the top of the file to the bottom, then you would get 0 and 0. If it begins from the bottom of the module and works up, then b will receive the initial value of a at the beginning of the simulation before it has been initialized to 0 (the value of any variable not set explicitily is set to X.) This is the way you can experience a race condition in a simulation. So be careful! Note that the 3rd initial block will execute as you expect because of the #1 there. That is a different point on the time wheel beyond time 0, consequently both of the earlier initial blocks have completed execution.


System tasks are available to handle simple I/O, and various design measurement functions. All system tasks are prefixed with $ to distinguish them from user tasks and functions. This section presents a short list of the most often used tasks. It is by no means a comprehensive list.

Program Language Interface provides a programmer with transferring control from Verilog to a program function written in C language. It is officially deprecated by IEEE Std 1364-2005 in favor of the newer Verilog Procedural Interface, which completely replaces the PLI.
The PLI enables Verilog to cooperate with other programs written in the C language such as test harness, Instruction Set Simulator of microcontroller, debugger, and so on. For example, it provides C functions named tf_putlongp() and tf_getlongp() which are used to write and read the argument of the current Verilog task or function, respectively.

For information on Verilog simulators, see List of Verilog Simulators.






