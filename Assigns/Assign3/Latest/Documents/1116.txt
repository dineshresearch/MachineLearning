Wireless sensor network
A wireless sensor network (WSN) is a wireless network consisting of spatially distributed autonomous devices using sensors to cooperatively monitor physical or environmental conditions, such as temperature, sound, vibration, pressure, motion or pollutants, at different locations.[1][2] The development of wireless sensor networks was originally motivated by military applications such as battlefield surveillance. However, wireless sensor networks are now used in many industrial and civilian application areas, including industrial process monitoring and control, machine health monitoring, environment and habitat monitoring, healthcare applications, home automation, and traffic control.[1][3]
In addition to one or more sensors, each node in a sensor network is typically equipped with a radio transceiver or other wireless communications device, a small microcontroller, and an energy source, usually a battery. The envisaged size of a single sensor node can vary from shoebox-sized nodes down to devices the size of grain of dust,[1] although functioning 'motes' of genuine microscopic dimensions have yet to be created. The cost of sensor nodes is similarly variable, ranging from hundreds of dollars to a few cents, depending on the size of the sensor network and the complexity required of individual sensor nodes.[1] Size and cost constraints on sensor nodes result in corresponding constraints on resources such as energy, memory, computational speed and bandwidth.[1]
A sensor network normally constitutes a wireless ad-hoc network, meaning that each sensor supports a multi-hop routing algorithm (several nodes may forward data packets to the base station).
In computer science and telecommunications, wireless sensor networks are an active research area with numerous workshops and conferences arranged each year.

The applications for WSNs are many and varied, but typically involve some kind of monitoring, tracking, and controlling. Specific applications for WSNs include habitat monitoring, object tracking, nuclear reactor control, fire detection, and traffic monitoring. In a typical application, a WSN is scattered in a region where it is meant to collect data through its sensor nodes.

Area monitoring is a common application of WSNs. In area monitoring, the WSN is deployed over a region where some phenomenon is to be monitored. For example, a large quantity of sensor nodes could be deployed over a battlefield to detect enemy intrusion instead of using landmines.[4] When the sensors detect the event being monitored (heat, pressure, sound, light, electro-magnetic field, vibration, etc), the event needs to be reported to one of the base stations, which can take appropriate action (e.g., send a message on the internet or to a satellite). Depending on the exact application, different objective functions will require different data-propagation strategies, depending on things such as need for real-time response, redundancy of the data (which can be tackled via data aggregation techniques), need for security, etc.

A number of WSN deployments have been done in the past in the context of environmental monitoring[5]. Many of these have been short lived, often due to the prototypical nature of the projects. A more long-lived deployment is monitoring the state of permafrost in the swiss alps: [The PermaSense Project], [PermaSense Live Data Browser]

Unique characteristics of a WSN include:
Sensor nodes can be imagined as small computers, extremely basic in terms of their interfaces and their components. They usually consist of a processing unit with limited computational power and limited memory, sensors (including specific conditioning circuitry), a communication device (usually radio transceivers or alternatively optical), and a power source usually in the form of a battery. Other possible inclusions are energy harvesting modules, secondary ASICs, and possibly secondary communication devices (e.g. RS-232 or USB).
The base stations are one or more distinguished components of the WSN with much more computational, energy and communication resources. They act as a gateway between sensor nodes and the end user.


Several standards are currently either ratified or under development for wireless sensor networks. ZigBee is a mesh-networking standard intended for uses such as embedded sensing, medical data collection, consumer devices like television remote controls, and home automation. Zigbee is promoted by a large consortium of industry players. WirelessHART is an extension of the HART Protocol and is specifically designed for Industrial applications like Process Monitoring and Control. WirelessHART was added to the overall HART protocol suite as part of the HART 7 Specification, which was approved by the HART Communication Foundation in June 2007[6]. 6LoWPAN [7] is the IETF standards track specification for the IP-to-MAC-Layer mapping for IPv6 on IEEE 802.15.4. ISA100 is a new standard under development that makes use of 6lowpan and provides additional agreements for industrial control applications[citation needed]. ISA100 is scheduled for completion in 2009. ZigBee, WirelessHART, and 6lowpan/ISA100 all are based on the same underlying radio standard: IEEE 802.15.4 - 2006.

The main challenge is to produce low cost and tiny sensor nodes. With respect to these objectives, current sensor nodes are mainly prototypes. Miniaturization and low cost are understood to follow from recent and future progress in the fields of MEMS and NEMS. Some of the existing sensor nodes are given below. Some of the nodes are still in research stage.
An overview of commonly used sensor network platforms, components, technology and related topics is available in the SNM - Sensor Network Museumtm.

Energy is the scarcest resource of WSN nodes, and it determines the lifetime of WSNs. WSNs are meant to be deployed in large numbers in various environments, including remote and hostile regions, with ad-hoc communications as key. For this reason, algorithms and protocols need to address the following issues:
Some of the "hot" topics in WSN software research are:

Operating systems for wireless sensor network nodes are typically less complex than general-purpose operating systems both because of the special requirements of sensor network applications and because of the resource constraints in sensor network hardware platforms. For example, sensor network applications are usually not interactive in the same way as applications for PCs. Because of this, the operating system does not need to include support for user interfaces. Furthermore, the resource constraints in terms of memory and memory mapping hardware support make mechanisms such as virtual memory either unnecessary or impossible to implement.
Wireless sensor network hardware is not different from traditional embedded systems and it is therefore possible to use embedded operating systems such as eCos or uC/OS for sensor networks. However, such operating systems are often designed with real-time properties. Unlike traditional embedded operating systems, however, operating systems specifically targeting sensor networks often do not have real-time support.
TinyOS[8] is perhaps the first[citation needed] operating system specifically designed for wireless sensor networks. Unlike most other operating systems, TinyOS is based on an event-driven programming model instead of multithreading. TinyOS programs are composed into event handlers and tasks with run to completion-semantics. When an external event occurs, such as an incoming data packet or a sensor reading, TinyOS calls the appropriate event handler to handle the event. Event handlers can post tasks that are scheduled by the TinyOS kernel some time later. Both the TinyOS system and programs written for TinyOS are written in a special programming language called nesC which is an extension to the C programming language. NesC is designed to detect race conditions between tasks and event handlers.
There are also operating systems that allow programming in C. Examples of such operating systems include Contiki,[9] MANTIS,[10] BTnut,[11] SOS[12] and Nano-RK.[13] Contiki is designed to support loading modules over the network and supports run-time loading of standard ELF files.[14] The Contiki kernel is event-driven, like TinyOS, but the system supports multithreading on a per-application basis.[15] Furthermore, Contiki includes protothreads that provide a thread-like programming abstraction but with a very small memory overhead.[16] Unlike the event-driven Contiki kernel, the MANTIS and Nano-RK kernels are based on preemptive multithreading.[17][18] With preemptive multithreading, applications do not need to explicitly yield the microprocessor to other processes. Instead, the kernel divides the time between the active processes and decides which process that currently can be run which makes application programming easier. Nano-RK is a real-time resource kernel that allows fine grained control of the way tasks get access to CPU time, networking and sensors. Like TinyOS and Contiki, SOS is an event-driven operating system.[19] The prime feature of SOS is its support for loadable modules. A complete system is built from smaller modules, possibly at run-time. To support the inherent dynamism in its module interface, SOS also focuses on support for dynamic memory management.[20] BTnut[21] is based on cooperative multi-threading and plain C code, and is packaged with a developer kit and tutorial[22]

There is considerable research effort currently invested in the design of middleware for WSN's.[3] In general approaches can be classified into distributed database, mobile agents, and event-based.[23]

Programming the sensor nodes is difficult when compared with normal computer systems. The resource constrained nature of these nodes gives rise to new programming models although most nodes are currently programmed in C.

WSNs are composed of a large number of sensor nodes, therefore, an algorithm for a WSN is implicitly a distributed algorithm. In WSNs the scarcest resource is energy, and one of the most energy-expensive operations is data transmission. For this reason, algorithmic research in WSN mostly focuses on the study and design of energy aware algorithms for data transmission from the sensor nodes to the base stations. Data transmission is usually multi-hop (from node to node, towards the base stations), due to the polynomial growth in the energy-cost of radio transmission with respect to the transmission distance.
The algorithmic approach to WSN differentiates itself from the protocol approach by the fact that the mathematical models used are more abstract, more general, but sometimes less realistic than the models used for protocol design.

There are platforms specifically designed to simulate Wireless Sensor Networks, like TOSSIM, which is a part of TinyOS. Traditional network simulators like ns-2 have also been used. A platform independent component based simulator with wireless sensor network framework,J-Sim(www.j-sim.org) can also be used. An extensive list of simulation tools for Wireless Sensor Networks can be found at the CRUISE WSN Simulation Tool Knowledgebase

The data gathered from wireless sensor networks is usually saved in the form of numerical data in a central base station. Additionally, the Open Geospatial Consortium (OGC) is specifying standards for interoperability interfaces and metadata encodings that enable real time integration of heterogeneous sensor webs into the Internet, allowing any individual to monitor or control Wireless Sensor Networks through a Web Browser. There are several techniques to retrieve data from the nodes ,some of the protocols rely on flooding mechanisms , other map the data to nodes by applying the concept of DHT[24] [25]


