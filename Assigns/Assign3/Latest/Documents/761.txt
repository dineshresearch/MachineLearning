DLL hell
In computing, DLL hell is a colloquial term for the complications that arise when working with dynamic link libraries (DLLs) used with Microsoft Windows operating systems, particularly legacy 16-bit editions. Although the term is Windows-specific (the more general term is dependency hell) the rhyme is often used to depict a dependency hell case.
DLL hell often shows up in a Windows alert pop-up that reports something similar to "A Required DLL File, Z.DLL, was not found" or "The procedure entry point Y couldn't be located in X.DLL" when users try to run an application, or during startup. This can also manifest itself more quietly as applications just not working properly. It takes a number of forms, as detailed below.

There are a number of problems commonly encountered with DLLs â€“ especially after numerous applications have been installed and uninstalled on a system. The difficulties include conflicts between DLL versions, difficulty in obtaining required DLLs, and having many unnecessary DLL copies.

DLL incompatibility has been caused by:
DLL hell was a very common phenomenon on pre-Windows NT versions of Microsoft operating systems, the primary cause being that the 16-bit operating systems did not restrict processes to their own memory space, thereby not allowing them to load their own version of a shared module that they were compatible with. Application installers were expected to be good citizens and verify DLL version information before overwriting the existing system DLLs. Standard tools to simplify application deployment (which always involves shipping the dependent operating system DLLs) were provided by Microsoft and other 3rd party tools vendors. Microsoft even required application vendors to use a standard installer and have their installation program certified to work correctly, before being granted use of the Microsoft logo. The good citizen installer approach did not mitigate the problem, as the rise in popularity of the Internet provided more opportunities to obtain non-conforming applications.

Various forms of DLL hell have been solved or mitigated over the years.

One of the simplest solutions to DLL hell in an application is to statically link against all the libraries. This is common in C/C++ applications, where, instead of having to worry about which version of MFC42.DLL is installed, the application is compiled to be statically linked against the same libraries. This eliminates the DLLs entirely, and is viable for standalone applications that are only using libraries - such as Microsoft Foundation Class Library - that offer a static option. The main purpose of DLLs (runtime library sharing between programs) is sacrificed though, and can prevent proper propagation of security fixes.

The DLL overwriting problem (referred to as DLL Stomping inside Microsoft) was somewhat reduced with Windows File Protection (WFP)[4] that was introduced in Windows 2000. This prevents unauthorized applications from overwriting system DLLs, unless they use the specific Windows APIs that permit this. There is still a risk that updates from Microsoft (such as Internet Explorer 7) are incompatible with existing applications.
Third-party applications cannot stomp on OS files unless they bundle windows updates with their installer, or if they disable the Windows File Protection service during installation.
Some other features that help to mitigate the problem are

The solutions here consist of having different copies of the same DLLs for each application, both on-disk and in memory.
An easy manual solution to conflicts was placing the different versions of the problem DLL into the applications' folders, rather than a system-wide folder. This works so long as the operating system is 32-bit or 64-bit, or that applications are not run simultaneously on a 16-bit platform. However, OLE prevented this before Windows XP, because earlier versions of Windows had a single registry of COM objects for all applications.
Windows XP introduced a solution called Side-by-Side Component Sharing (MSDN page), which loads separate copies of DLLs for each application that requires them (and thus allows applications that require conflicting DLLs to run simultaneously). This approach eliminates conflicts by allowing applications to load unique versions of a module into their address space, while preserving the primary benefit of sharing DLLs between applications (i.e. reducing memory use) by using memory mapping techniques to share common code between different processes that do still use the same module. However DLLs that use shared data between multiple processes cannot take this approach.[5] One negative side-effect is that orphaned instances of DLLs may not be updated during automated processes.

There are several countermeasures known to avoid DLL hell, which have to be used simultaneously for optimal results:

In 2000, Microsoft publicly unveiled the .NET Framework, which included a new version of a package deployment system called assemblies.[7] This framework also provided support for a common language runtime (essentially moving much DLL code to a base foundation class). This concept, along with file versioning, is often seen as one of the last operating system constructs that had failed to bridge the gap between OpenVMS and Windows NT, which shared a common operating systems architecture.[citation needed]



