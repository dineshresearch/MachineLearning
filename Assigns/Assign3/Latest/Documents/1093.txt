Computer Go
Game specifics
History & Culture
Players & Organisations
Computers & Mathematics
Computer go is the field of artificial intelligence (AI) dedicated to creating a computer program that plays go, an ancient board game.

Go has long been considered a difficult challenge in the field of AI and has been seen harder to solve than chess. The first Go program was written by Albert Zobrist in 1968 as part of his thesis on pattern recognition. It introduced an influence function to estimate territory and Zobrist hashing to detect ko. Recent developments in Monte Carlo Tree Search and machine learning have brought the best programs to good dan level on the small 9x9 board; however, while the techniques which have brought such progress in the 9x9 case have been applied on the 19x19 board with some success, dan level play has not yet been reached at least with publicly available software on ordinary personal computers.
Currently, the best Go programs running on stock hardware are ranked as 1 dan - 3 kyu[1]. Only a decade ago, very strong players were able to beat computer programs at handicaps of 25â€“30 stones, an enormous handicap that few human players would ever take. There is a case where the winning program in the 1994 World Computer Go Championship, Go Intellect, lost all 3 games against the youth players on a 15-stone handicap.[2] In general, players who understood and exploit a program's weaknesses could win with much larger handicaps than typical players.[3]
On August 7, 2008, the computer program MoGo running on 25 nodes (800 cores) of the Huygens cluster in Amsterdam beat professional Go player Myungwan Kim (8p) in a nine stone handicap game on the 19x19 board on the KGS Go Server. In after-game commentary, Kim estimated the playing strength of this machine as being in the range of 2â€“3 amateur dan.[4] In a rematch on September 20, Kim won two games giving MoGo nine stones.[5] On August 26, 2008, Mogo beat an Amateur 6d with five stones of handicap, this time running on 200 cores of the Huygens cluster.
On September 4, 2008, the program Crazy Stone running on an 8-core personal computer won against 30 year old female professional player, Aoba Kaori (4p), receiving a handicap of eight stones. The time control was 30 seconds per move. White resigned after 185 moves. The game was played during the FIT2008 conference in Japan.[6]
In February 2009, MoGo won two 19x19 games against professional Go players in the Taiwan Open 2009. With a 7-stones handicap the program defeated Jun-Xun Zhou (9p), and with a 6-stones handicap it defeated Li-Chen Chien (1p).[7]
On February 14, 2009, Many Faces of Go won against James Kerwin (1p) with a handicap of seven stones. The game was played during the 2009 AAAS general meeting in Chicago.[8]
These results can be viewed as evidence pointing towards the possibility of amateur dan-level play if contemporary software is combined with strong hardware, but more games will need to be played at this level until solid conclusions of any kind can be drawn.

For a long time it was a widely held opinion that computer Go posed a problem fundamentally different to computer chess insofar as it was believed that methods relying on fast global search compared to human experts combined to relatively little domain knowledge would not be effective for Go. Therefore, a large part of the computer Go development effort was during these times focused on ways of representing human-like expert knowledge and combining this with local search to answer questions of a tactical nature. The result of this were programs that handled many situations well but which had very pronounced weaknesses compared to their overall handling of the game. Also, these classical programs gained almost nothing from increases in available computing power per se and progress in the field was generally slow. Therefore, creating a strong Go-playing program was by many seen as something that could, if at all, be achieved only in the far future and possibly only with fundamental advances in general artificial intelligence technology. Even writing a program capable of automatically determining the winner of a finished game was seen as no trivial matter.
The advent of programs based on Monte-Carlo search starting in 2006 changed this situation in many ways, although the gap between really strong human players and the strongest go programs remains considerable.

The large board (19x19, 361 intersections) is often noted as one of the primary reasons why a strong program is hard to create. The large board size is a problem to the extent that it prevents an alpha-beta searcher without significant search extensions or pruning heuristics from achieving deep look-ahead.
So far, the largest game of Go being completely solved has been played on a 5Ã—5 board. It was achieved in 2002, with black winning by 25 points (the entire board), by a computer program called MIGOS (MIni GO Solver).[9]

Continuing the comparison to chess, Go moves are not as limited by the rules of the game. For the first move in chess, the player has twenty choices. Go players begin with a choice of 55 distinct legal moves, accounting for symmetry. This number rises quickly as symmetry is broken and soon almost all of the 361 points of the board must be evaluated. Some are much more popular than others, some are almost never played, but all are possible.

As a chess game progresses (as well as most other games such as checkers, draughts, and backgammon), pieces disappear from the board, simplifying the game. Each new Go move, on the contrary, adds new complexities and possibilities to the situation, at least until an area becomes developed to the point of being 'settled'.

The fact that computer Go programs are significantly weaker than computer chess programs has served to generate research into many new programming techniques. The techniques which proved to be the most effective in computer chess have generally shown to be mediocre at Go.
While a simple material counting evaluation is not sufficient for decent play in chess, it is often the backbone of a chess evaluation function, when combined with more subtle considerations like isolated pawns, rooks on open verticals, pawns in the center of the board and so on. These rules can be formalised easily, providing a reasonably good evaluation function that can run quickly.
These types of positional evaluation rules cannot efficiently be applied to Go. The value of a Go position depends on a complex analysis to determine whether or not the group is alive, which stones can be connected to one another, and heuristics around which a strong position has influence, or the extent to which a weak position can be attacked.

Another problem comes from the difficulty of creating a good evaluation function for Go. More than one move can be regarded as the best depending on how you use that stone and what your strategy is. In order to choose a move, the computer must evaluate different possible outcomes and decide which is best. This is difficult due to the delicate trade-offs present in Go. For example, it may be possible to capture some enemy stones at the cost of strengthening the opponent's stones elsewhere. Whether this is a good trade or not can be a difficult decision, even for human players. The computational complexity also shows here as a move might not be immediately important, but after many moves could become highly important as other areas of the board take shape.

Sometimes it is mentioned in this context that various difficult combinatorial problems (in fact, any NP-complete problem) can be converted to Go problems; however, the same is true for other abstract board games, including chess and minesweeper, when suitably generalised to a board of arbitrary size. NP-complete problems do not tend in their general case to be easier for unaided humans than for suitably programmed computers: it is doubtful that unaided humans would be able to compete successfully against computers in solving, for example, instances of the subset sum problem. Hence, the idea that we can convert some NP-complete problems into Go problems does not help in explaining the present human superiority in Go.

Given that the endgame contains fewer possible moves than the opening or middle game, one could suppose that it was easier to play, and thus that computers should be easily able to tackle it. In chess, computer programs perform worse in endgames because the ideas are long-term; unless the number of pieces is reduced to an extent that allows taking advantage of solved endgame tablebases.
The application of surreal numbers to the endgame in Go, a general game analysis pioneered by John H. Conway, has been further developed by Elwyn R. Berlekamp and David Wolfe and outlined in their book, Mathematical Go (ISBN 1-56881-032-6). While not of general utility in most playing circumstances, it greatly aids the analysis of certain classes of positions.
Nonetheless, although elaborate study has been conducted, Go endgames have been proven to be PSPACE-hard. There are many reasons why they are so hard:
Thus, it is very unlikely that it will be possible to program a reasonably fast algorithm for playing the Go endgame flawlessly, let alone the whole Go game.[12]

People feel that computers are bad at Go because we compare them with humans. Perhaps computers aren't particularly bad at Go; rather, humans are particularly good at it.[13] Go, compared with other two-player games of complete information, has features that make it particularly easy for humans. The pieces never move about (as they do in Chess), nor change state (as they do in Reversi). These features make it easy for humans to "read" long sequences of moves, while being irrelevant to a computer program.
In those rare Go positions known as "ishi-no-shita", in which stones are repeatedly captured and re-played on the same points, humans have reading problems, while they are easy for computers.

One of the main concerns for a Go player is which groups of stones can be kept alive and which can be captured. This general class of problems is known as life and death. The most direct strategy for calculating life and death is to perform a tree search on the moves which potentially affect the stones in question, and then to record the status of the stones at the end of the main line of play.
However, within time and memory constraints, it is not generally possible to determine with complete accuracy which moves could affect the 'life' of a group of stones. This implies that some heuristic must be applied to select which moves to consider. The net effect is that for any given program, there is a trade-off between playing speed and life and death reading abilities.

A problem that all Go programs must solve is how to represent the current state of the game. For programs that use extensive searching techniques, this representation needs to be copied and modified for each new hypothetical move considered. This need places the additional constraint that the representation should either be small enough to be copied quickly or flexible enough that a move can be made and undone easily.
The most direct way of representing a board is as a 1 or 2-dimensional array, where each space in the array represents a point on the board, and can take on a value corresponding to a white stone, a black stone, or an empty space. Additional data is needed to store how many stones have been captured, whose turn it is, and which spaces are illegal due to Ko rule.
Most programs, however, use more than just the raw board information to evaluate positions. Data such as which stones are connected in strings, which strings are associated with each other, which groups of stones are in risk of capture and which groups of stones are effectively dead is necessary to make an accurate evaluation of the position. While this information can be extracted from just the stone positions, much of it can be computed more quickly if it is updated in an incremental, per-move basis. This incremental updating requires more information to be stored as the state of the board, which in turn can make copying the board take longer. This kind of trade-off is very indicative of the problems involved in making fast computer Go programs.
An alternative method is to have a single board and make and takeback moves so as to minimise the demands on computer memory and have the results of the evaluation of the board stored. This avoids having to copy the information over and over again.


Historically, GOFAI (Good Old Fashioned AI) techniques have been used to approach the problem of Go AI. More recently, neural networks are being looked at as an alternative approach. One example of a program which uses neural networks is WinHonte[14].
These approaches attempt to mitigate the problems of the game of Go having a high branching factor and numerous other difficulties.
Computer Go research results are being applied to other similar fields such as cognitive science, pattern recognition and machine learning.[15] Combinatorial Game Theory, a branch of applied mathematics, is a topic relevant to computer Go.[15]

The only choice a program needs to make is where to place its next stone. However, this decision is made difficult by the wide range of impacts a single stone can have across the entire board, and the complex interactions various stones groups can have with each other. Various architectures have arisen for handing this problem. The most popular are using some form of tree search, the application of Monte-Carlo methods, the creation of knowledge-based systems, and the use of machine learning. Few programs use only one of these techniques exclusively; most combine portions of each into one synthetic system.

One traditional AI technique for creating game playing software is to use a minimax tree search. This involves playing out all hypothetical moves on the board up to a certain point, then using an evaluation function to estimate the value of that position for the current player. The move which leads to the best hypothetical board is selected, and the process is repeated each turn. While tree searches have been very effective in computer chess, they have seen less success in Computer Go programs. This is partly because it has traditionally been difficult to create an effective evaluation function for a Go board, and partly because the large number of possible moves each side can make each leads to a high branching factor. This makes this technique very computationally expensive. Because of this, many programs which use search trees extensively can only play on the smaller 9Ã—9 board, rather than full 19Ã—19 ones.
There are several techniques, which can greatly improve the performance of search trees in terms of both speed and memory. Pruning techniques such as Alpha-beta pruning, Principal Variation Search, and MTD-f can reduce the effective branching factor without loss of strength. Likewise, caching techniques, such as transposition tables can reduce the amount of repeated effort, especially when combined with an iterative deepening approach. In order to quickly store a full sized Go board in a transposition table, a hashing technique for mathematically summarizing is generally necessary. Zobrist hashing is very popular in Go programs because it has low collision rates, and can be iteratively updated at each move with just two XORs, rather than being calculated from scratch. Even using these performance-enhancing techniques, full tree searches on a full sized board are still prohibitively slow. Searches can be sped up by using large amounts of domain specific pruning techniques, such as not considering moves where your opponent is already strong, and selective extensions like always considering moves next to groups of stones which are about to be captured. However, both of these options introduce a significant risk of not considering a vital move which would have changed the course of the game.
Results of computer competitions show that pattern matching techniques for choosing a handful of appropriate moves combined with fast localized tactical searches (explained above) are sufficient to produce a competitive program. For example, GNU Go is competitive, yet does not have a full-board search.

Novices often learn a lot from the game records of old games played by master players. There is a strong hypothesis that suggests that acquiring Go knowledge is a key to make a strong computer Go. For example, Tim Kinger and David Mechner argue that "it is our belief that with better tools for representing and maintaining Go knowledge, it will be possible to develop stronger Go programs." They propose two ways: recognizing common configurations of stones and their positions and concentrating on local battles. "... Go programs are still lacking in both quality and quantity of knowledge."[16]
After implementation, the use of expert knowledge has been proved very effective in programming Go software. Hundreds of guidelines and rules of thumb for strong play have been formulated by both high level amateurs and professionals. The programmer's task is to take these heuristics, formalize them into computer code, and utilize pattern matching and pattern recognition algorithms to recognize when these rules apply. It is also important to have a system for determining what to do in the event that two conflicting guidelines are applicable.
Most of the relatively successful results come from programmers' individual skills at Go and their personal conjectures about Go, but not from formal mathematical assertions; they are trying to make the computer mimic the way they play Go. "Most competitive programs have required 5â€“15 person-years of effort, and contain 50â€“100 modules dealing with different aspects of the game."[17]
This method has until recently been the most successful technique in generating competitive Go programs on a full sized board. Some example of programs which have relied heavily on expert knowledge are Handtalk (later known as Goemate), The Many Faces of Go, Go Intellect, and Go++, each of which has at some point been considered the world's best go program.
Nevertheless, adding knowledge of Go sometimes weakens the program because some superficial knowledge might bring mistakes: "the best programs usually play good, master level moves. However, as every games player knows, just one bad move can ruin a good game. Program performance over a full game can be much lower than master level."[17]

One major alternative to using hand-coded knowledge and searches is the use of Monte-Carlo methods. This is done by generating a list of potential moves, and for each move playing out thousands of games at random on the resulting board. The move which leads to the best set of random games for the current player is chosen as the best move. The advantage of this techni
