Low Level Virtual Machine
The Low Level Virtual Machine, generally known as LLVM, is a compiler infrastructure, written in C++, which is designed for compile-time, link-time, run-time, and "idle-time" optimization of programs written in arbitrary programming languages. Originally intended to replace the existing back-end in GCC with a more modern substrate, the success of LLVM has since spawned a wide variety of new front-ends intended to work with it and replace larger portions of the GCC stack.
The LLVM project started in 2000 at the University of Illinois at Urbana-Champaign, primarily under the direction of Chris Lattner. In early 2005, Apple Inc. hired Lattner and formed a team to work on the LLVM system for various uses within Apple's development systems.[1] Apple is the primary sponsor of ongoing LLVM development. It is released under an BSD-style license and has a wide group of active developers.

LLVM can replace most of the "lower levels" of the GCC toolchain, offering more aggressive optimization of GCCs three address code intermediate form (IF). LLVM supports a language-independent instruction set and type system. Each instruction is in static single assignment form (SSA), meaning that each variable (called a typed register) is assigned once and is frozen. This helps simplify the analysis of dependencies among variables. LLVM allows code to be compiled statically, as it is under the traditional GCC system, or left for late-compiling from the IF to machine code in a just-in-time compiler (JIT) in a fashion similar to Java.
Any form of type conversion, from coercion to the downcasting of an object, is performed explicitly using the cast instruction. LLVM has basic types, like integers of fixed sizes, and exactly five derived types: pointers, arrays, vectors, structures, and functions. A type construct in a concrete language can be represented by combining these basic types in LLVM. For example, a class in C++ can be represented by a combination of structures, functions and arrays of function pointers.
The LLVM JIT compiler is capable of optimizing unnecessary static branches out of a program at runtime, and is therefore useful for partial evaluation in cases where a program has many optionsâ€”most of which can easily be determined unnecessary in a specific environment. Because of this, it is used in the OpenGL pipeline of Mac OS X v10.5 (Leopard) to provide support for missing hardware features.[2] Graphics code within the OpenGL stack was left in IF form, and then compiled when run on the target machine. On systems with high-end GPUs the resulting code was quite thin, passing the instructions onto the GPU with minimal changes. On systems with low-end graphics the code would create procedure to run on the local CPU to handle any instructions that the GPU could not run internally. LLVM was instrumental in improving performance on low-end machines using Intel GMA chipsets.

LLVM was originally written as a more aggressive, higher performance system for the existing GCC stack, and many of the GCC front-ends have been modified to work with it. LLVM currently supports the compilation of C, C++, Fortran, Objective-C, Ada, D, using front-ends derived from version 4.0.1 and 4.2 of the GNU Compiler Collection (GCC).
However, widespread interest in LLVM has led to a number of efforts to develop entirely new front-ends for a variety of languages. One that has received the most attention is clang, a new compiler supporting C, Obj-C and C++. Primarily supported by Apple, clang is aimed at replacing the C/Obj-C compiler in the GCC system with a modern system that is more easily integrated with IDEs and had wider support for multithreading. Obj-C development under GCC was somewhat moribund and Apple's changes to the language were supported in a separately maintained branch. Creating their own compiler allowed them to address many of the same problems LLVM addressed in terms of IDE integration and other modern features, while also making the primary development branch the primary Obj-C implementation.
The Essential Haskell Compiler can generate code for LLVM which, though the generator is in the early stages of development, has been shown in many cases to be more efficient than the C code generator.[3] There are many other components in various stages of development; including, but not limited to, a Java bytecode front-end, a CIL front-end, a CPython front-end, and a new graph coloring register allocator.



