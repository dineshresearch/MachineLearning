DOM events
DOM (Document Object Model) events allow event-driven programming languages like JavaScript, JScript, ECMAScript, VBScript and Java to register various event handlers/listeners on the element nodes inside a DOM tree, e.g. HTML, XHTML, XUL and SVG documents.
Historically, like DOM, the event models used by various web browsers had some significant differences. This caused compatibility problems. To combat this, the event model was standardized by the W3C in DOM Level 2.



There is a huge collection of events that can be generated by most element nodes:
Note that the event classification above is not exactly the same as W3C's classification.
For elements, it fires when the target element and all of its content has finished loading
For elements, it fires when the target element or any of its content has been removed
Note that the events whose names start with ‚ÄúDOM‚Äù are currently not well supported. Mozilla and Opera support DOMAttrModified, DOMNodeInserted, DOMNodeRemoved and DOMCharacterDataModified. Safari, as of version 1.3, also supports these methods.

Two major types of events are added by Microsoft and in some cases can only be used in Internet Explorer others have been implemented as de-facto standards by other browsers:
Note that Mozilla, Safari and Opera also support readystatechange event for the XMLHttpRequest object. Mozilla also supports the beforeunload event using traditional event registration method (DOM Level 0). Mozilla and Safari also support contextmenu, but Internet Explorer for the Mac does not.

In addition to the common/W3C events, Mozilla defined a set of events that work only with XUL elements.

For Mozilla and Opera 9, there are also undocumented events known as "DOMContentLoaded" and "DOMFrameContentLoaded" which fire when the DOM content is loaded. These are different from "load" as they fire before the loading of related files (e.g., images). The "DOMContentLoaded" event was also implemented in Safari 3.1.
Opera 9 also supports the Web Forms 2.0 events "DOMControlValueChanged", "invalid", "forminput" and "formchange".

Consider the situation when there are 2 elements nested together. Both have event handlers registered on the same event type, say "click". When the user clicks on the inner element, there are two possible ways to handle it:
W3C takes a middle position in this struggle. Events are first captured until it reaches the target element, and then bubbled up. During the event flow, an event can be responded to at any element in the path (an observer) in either phase by causing an action, and/or by stopping the event (with method event.stopPropagation() for Mozilla and command event.cancelBubble = true for Internet Explorer), and/or by cancelling the default action for the event.

The Event object provides a lot of information about a particular event, including information about target element, key pressed, mouse button pressed, mouse position, etc. Unfortunately, there are very serious browser incompatibilities in this area. Hence only the W3C Event object is discussed in this article.


This event handling model was introduced by Netscape Navigator, and remains the most cross-browser model as of 2005[update]. There are two model types: inline model and traditional model.

In the inline model, event handlers are added as attribute of element. Event handlers can also be removed:
In the example above, an alert dialog box with the message "Hello Joe" will appear when the hyperlink is clicked and open URI in href attribute.
The default action can be cancelled by returning false in the event handler:
In the example above, the browser will not go to "example.com" when the hyperlink is clicked.
One common misconception with the inline model is the belief that it allows the registration of event handlers with custom arguments, e.g. name in the helloWorld function. While it may seem like that is the case in the example above, what is really happening is that the JavaScript engine of the browser creates an anonymous function containing the statements in the onclick attribute. The onclick handler of the element would be bound to the following anonymous function:
This limitation of the JavaScript event model is usually overcome by assigning attributes to the function object of the event handler or by using closures.

In the traditional model, event handlers can be added/removed by scripts. Like the inline model, each event can only have one event handler registered. The event is added by assigning the handler name to the event property of the element object. To remove an event handler, simply set the property to null:
To add parameters:
Inner functions preserve their scope.

The W3C designed a more flexible event handling model in DOM Level 2.

Some useful things to know†:
The main difference from the traditional model is that multiple event handlers can be registered for the same event. The useCapture option can also be used to specify that the handler should be called in the capture phase instead of the bubbling phase. This model is supported by Mozilla, Opera, Safari, Chrome and Konqueror.
A rewrite of the example used in traditional model:

Microsoft do not follow the W3C model, as their own model was created prior to the ratification of the W3C standard.
Some useful things to know†:
Again, this model differs from the traditional model in that multiple event handlers can be registered for the same event. However the useCapture option can not be used to specify that the handler should be called in the capture phase. This model is supported by Microsoft Internet Explorer and Trident based browsers (e.g. Maxthon, Avant Browser).
A rewrite of the example used in traditional model:



