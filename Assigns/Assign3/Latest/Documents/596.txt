Cross-platform
In computing, cross-platform (also known as multi-platform) is a term used to refer to computer software or computing methods and concepts that are implemented and inter-operate on multiple computer platforms[1][2]. Cross-platform software may be divided into two types; one requires individual building or compilation for each platform that it supports, and the other one can be directly run on any platform without special preparation, e.g., software written in an interpreted language or pre-compiled portable bytecode for which the interpreters or run-time packages are common or standard components of all platforms.
For example, a cross-platform application may run on Microsoft Windows on the x86 architecture, Linux on the x86 architecture and Mac OS X on either the PowerPC or x86 based Apple Macintosh systems. A cross-platform application may run on as many as all existing platforms, or on as few as two platforms.

A platform is a combination of hardware and software used to run software applications. A platform can be described simply as an operating system or computer architecture, or it could be the combination of both. Probably the most familiar platform is Microsoft Windows running on the x86 architecture. Other well-known desktop computer platforms include Linux/Unix and Mac OS X (both of which are themselves cross-platform). There are, however, many devices such as cellular telephones that are also effectively computer platforms but less commonly thought about in that way. Application software can be written to depend on the features of a particular platform—either the hardware, operating system, or virtual machine it runs on. The Java platform is a virtual machine platform which runs on many operating systems and hardware types, and is a common platform for software to be written for.

A hardware platform can refer to a computer’s architecture or processor architecture. For example, the x86 and x86-64 CPUs make up one of the most common computer architectures in use in home machines today. These machines commonly run Microsoft Windows, though they can run other operating systems as well, including Linux, OpenBSD, NetBSD, Mac OS X and FreeBSD.

Software platforms can either be an operating system or programming environment, though more commonly it is a combination of both. A notable exception to this is Java, which uses an operating system independent virtual machine for its compiled code, known in the world of Java as bytecode. Examples of software platforms include:

As previously noted, the Java platform is an exception to the general rule that an operating system is a software platform. The Java language provides a virtual machine, or a “virtual CPU” which runs all of the code that is written for the language. This enables the same executable binary to run on all systems which support the Java software, through the Java Virtual Machine. Java executables do not run directly on the operating system; that is, neither Windows nor Linux execute Java programs directly.
Because of this, however, Java is limited in that it does not directly support system-specific functionality. JNI can be used to access system specific functions, but then the code is likely no longer portable. Java programs can run on at least the Microsoft Windows, Mac OS X, Linux, and Solaris operating systems, and so the language is limited to functionality that exists on all these systems. This includes things such as computer networking, Internet sockets, but not necessarily raw hardware input/output.

In order for software to be considered cross-platform, it must be able to function on more than one computer architecture or operating system. This can be a time-consuming task given that different operating systems have different application programming interfaces or APIs (for example, Linux uses a different API for application software than Windows does).
Just because a particular operating system may run on different computer architectures, that does not mean that the software written for that operating system will automatically work on all architectures that the operating system supports. One example as of August, 2006 was OpenOffice.org, which did not natively run on the AMD64 or Intel 64 lines of processors implementing the x86-64 64-bit standards for computers; this has since been changed, and the OpenOffice.org suite of software is “mostly” ported to these 64-bit systems[1]. This also means that just because a program is written in a popular programming language such as C or C++, it does not mean it will run on all operating systems that support that programming language—or even on the same operating system on a different architecture.

Web applications are typically described as cross-platform because, ideally, they are accessible from any of various web browsers within different operating systems. Such applications generally employ a client-server system architecture, and vary widely in complexity and functionality. This wide variability significantly complicates the goal of cross-platform capability, which is routinely at odds with the goal of advanced functionality.

Basic web applications perform all or most processing from a stateless web server, and pass the result to the client web browser. All user interaction with the application consists of simple exchanges of data requests and server responses. These types of applications were the norm in the early phases of World Wide Web application development. Such applications follow a simple transaction model, identical to that of serving static web pages. Today, they are still relatively common, especially where cross-platform compatibility and simplicity are deemed more critical than advanced functionalities.

Prominent examples of advanced web applications include the Web interface to Gmail, A9.com, and the maps.live.com website, part of the Live Search service from Microsoft. Such advanced applications routinely depend on additional features found only in the more recent versions of popular web browsers. These dependencies include Ajax, JavaScript, “Dynamic” HTML, SVG, and other components of rich internet applications. Older versions of popular browsers tend to lack support for certain features.

Because of the competing interests of cross-platform compatibility and advanced functionality, numerous alternative web application design strategies have emerged.
Such strategies include:

Graceful degradation attempts to provide the same or similar functionality to all users and platforms, while diminishing that functionality to a ‘least common denominator’ for more limited client browsers. For example, a user attempting to use a limited-feature browser to access Gmail may notice that Gmail switches to “Basic Mode,” with reduced functionality. Some view this strategy as a lesser form of cross-platform capability.

Separation of functionality attempts to simply omit those subsets of functionality that are not capable from within certain client browsers or operating systems, while still delivering a ‘complete’ application to the user. (see also Separation of concerns).

Multiple codebase applications present different versions of an application depending on the specific client in use. This strategy is arguably the most complicated and expensive way to fulfill cross-platform capability, since even different versions of the same client browser (within the same operating system) can differ dramatically between each other. This is further complicated by the support for “plugins” which may or may not be present for any given installation of a particular browser version.

Third party libraries attempt to simplify cross-platform capability by ‘hiding’ the complexities of client differentiation behind a single, unified API.

One complicated aspect of cross-platform web application design is the need for software testing. In addition to the complications mentioned previously, there is the additional restriction that some browsers prohibit installation of different versions of the same browser on the same operating system. Techniques such as full virtualization are sometimes used as a workaround for this problem.

Although web applications are becoming increasingly popular, many computer users still use traditional application software which does not rely on a client/web-server architecture. The distinction between “traditional” and “web” applications is not always unambiguous, however, because applications have many different features, installation methods and architectures; and some of these can overlap and occur in ways that blur the distinction. Nevertheless, this simplifying distinction is a common and useful generalization.

Traditionally in modern computing, application software has been distributed to end-users as binary images, which are stored in executables, a specific type of binary file. Such executables only support the operating system and computer architecture that they were built for—which means that making a “cross-platform executable” would be something of a massive task, and is generally not done.
For software that is distributed as a binary executable, such as software written in C or C++, the programmer must build the software for each different operating system and computer architecture. For example, Mozilla Firefox, an open-source web browser, is available on Microsoft Windows, Mac OS X (both PowerPC and x86 through something Apple calls a Universal binary), and Linux on multiple computer architectures. The three platforms (in this case, Windows, Mac OS X, and Linux) are separate executable distributions, although they come from the same source code.
In the context of binary software, cross-platform programs are written in the source code and then “translated” to each system that it runs on through compiling it on different platforms. Also, software can be ported to a new computer architecture or operating system so that the program becomes more cross-platform than it already is. For example, a program such as Firefox, which already runs on Windows on the x86 family, can be modified and re-built to run on Linux on the x86 (and potentially other architectures) as well.
As an alternative to porting, cross-platform virtualization allows applications compiled for one CPU and operating system to run on a system with a different CPU and/or operating system, without modification to the source code or binaries. As an example, Apple's Rosetta software, which is built into Intel-based Apple Macintosh computers, runs applications compiled for the previous generation of Macs that used PowerPC CPUs. Another example is IBM PowerVM Lx86, which allows Linux/x86 applications to run unmodified on the Linux/Power operating system.

A script can be considered to be cross-platform if the scripting language is available on multiple platforms and the script only uses the facilities provided by the language. That is, a script written in Python for a Unix-like system will likely run with little or no modification on Windows, because Python also runs on Windows; there is also more than one implementation of Python that will run the same scripts (e.g., IronPython for .NET). The same goes for many of the open source programming languages that are available and are scripting languages.
Unlike binary executables, the same script can be used on all computers that have software to interpret the script. This is because the script is generally stored in plain text in a text file. There may be some issues, however, such as the type of new line character that sits between the lines. Generally, however, little or no work has to be done to make a script written for one system, run on another.
Some quite popular cross-platform scripting or interpreted languages are:

Cross-platform is a term that can also apply to video games released on a range of video game consoles, specialized computers dedicated to the task of playing games. Examples of cross-platform games include:
Each has been released across a variety of gaming platforms, such as the Nintendo GameCube, PlayStation 2, Xbox, personal computers (PCs), and mobile devices.
The characteristics of a particular system may lengthen the time taken to implement a video game across multiple platforms. So, a video game may initially be released on a few platforms and then later released on remaining platforms. Typically, this situation occurs when a new gaming system is released, because video game developers need to acquaint themselves with the hardware and software associated with the new console.
Some games may not become cross-platform because of licensing agreements between developers and video game console manufacturers that limit development of a game to one particular console. As an example, Disney could create a game with the intention of release on the latest Nintendo and Sony game consoles. Should Disney license the game with Sony first, Disney may in exchange be required to release the game solely on Sony’s console for a short time or indefinitely — effectively prohibiting a cross-platform release for the duration.
Several developers have implemented means to play games online while using different platforms. Epic Games, Microsoft, and Valve Software all possess technology that allows Xbox 360 and PlayStation 3 gamers to play with PC gamers, leaving the decision of which platform to use to consumers. The first game to allow this level of interactivity between PC and console games was Quake 3.[citation needed]
Games that feature cross-platform online play include:

Software that is platform independent does not rely on any special features of any single platform, or, if it does, handles those special features such that it can deal with multiple platforms.

Cross-platform programming is the practice of actively writing software that will work on more than one platform.

There are different ways of approaching the problem of writing a cross-platform application program. One such approach is simply to create multiple versions of the same program in different source trees—in other words, the Windows version of a program might have one set of source code files and the Macintosh version might have another, while a FOSS *nix system might have another. While this is a straightforward approach to the problem, it has the potential to be considerably more expensive in development cost, development time, or both, especially for the corporate entities. The id
