make (software)
In software development, make is a utility for automatically building executable programs and libraries from source code. Files called makefiles specify how to derive the target program from each of its dependencies. Make typically decides where to start through topological sorting. Though Integrated Development Environments and language-specific compiler features can also be used to manage the build process in modern systems, make remains widely used, especially in Unix-based platforms.

There are now a number of dependency-tracking build utilities, but make is one of the most wide-spread, primarily due to its inclusion in Unix, starting with the PWB/UNIX 1.0, which featured a variety of tools targeting software development tasks. It was originally created by Stuart Feldman in 1977 at Bell Labs. In 2003 Dr. Feldman received the ACM Software System Award for the invention of this important tool.[1]
Before make's introduction, the Unix build system would most likely consist of "make" and "install" shell scripts accompanying a program's source. Being able to combine the commands for the different targets into a single file, and being able to abstract out dependency tracking and archive handling, was an important step in the direction of modern build environments.

Make has gone through a number of rewrites, and a number of from-scratch variants which used the same file format and basic algorithmic principles, and also provided a number of their own non-standard enhancements, in the time that followed. Some of them are:
POSIX includes standardization of the basic features and operation of the make utility, and is implemented with varying degrees of completeness in Unix-based versions of make. In general, simple makefiles may be used between various versions of make with reasonable success. Some versions of GNU make and BSD make will look first for files named "GNUmakefile" and "BSDmakefile" respectively, which allows one to put makefiles which use implementation-defined behaviour in separate locations.

In its basic form, Make requires the programmer to manually track all dependencies between files in the project. This process is error prone, since a forgotten or an extra dependency might not be immediately obvious, but instead surfaces as subtle bugs in the software. It is possible to create make files that generate some of these dependencies, but a more common solution is to use one of the available generators to make, e.g. the Automake toolchain provided by the GNU Project.
Another problem not well handled by make is the tailoring of a build process to a given platform. E.g, the compiler used on one platform might not accept the same options as the one used on another. This problem is typically handled by generating platform specific build instructions, which in turn are processed by make. Common tools for this process are Autoconf and CMake.
The syntax used by Make includes the use of tab, a whitespace character. Many editors do not provide very clear visual clues to the presence of tabs rather than spaces, and tab characters are not represented uniformly across editors in any case, with size varying from as little as 2 spaces to 8 spaces. Thus, the syntax of make is often subject to criticism. Some projects, such as Apache Ant, have attempted to redo make with a better syntax, with mixed success. For programmers using makefile generators, this issue is likely unimportant.
With the advent of modern Integrated Development Environments, especially on non-Unix platforms, many programmers do not manually manage dependency tracking, or even the listing of which files are part of a project. Instead, the task is automated by the integrated environment. Likewise, many modern programming languages have language-specific ways of listing dependencies which are more efficiently tracked through the use of language-specific build utilities. These approaches typically have the drawback that support for arbitrary build instructions is limited.
Make is considered to be a mainly declarative programming language,[2][3][4][5] and these languages are sometimes considered more difficult for programmers used to imperative programming languages.[6]

A makefile consists of lines of text which define a file (or set of files) or a rule name as depending on a set of files. Output files are marked as depending on their source files, for example, and on files which they include internally, since they all affect the output. After each dependency is listed, a series of lines of tab-indented text may follow which define how to transform the input into the output, if the former has been modified more recently than the latter. In the case where such definitions are present, they are referred to as "build scripts" and are passed to the shell to generate the target file. The basic structure is:[7]
A makefile also can contain definitions of variables and inclusion of other makefiles. Variables in makefiles may be overridden in the command line arguments passed to the make utility. This allows users to specify different behaviour for the build scripts and how to invoke programs, among other things. For example, the variable "CC" is frequently used in makefiles to refer to a C compiler, and the user may wish to provide an alternate compiler to use.

Below is a very simple makefile that would compile a source called "helloworld.c" using cc, a C compiler. The PHONY tag is a technicality that tells make that a particular target name does not produce an actual file. The $@ and $< are two of the so-called automatic variables and stand for the target name and so-called "implicit" source, respectively. There are a number of other automatic variables.[7][8]



