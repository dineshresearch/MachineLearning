Game programmer
A game programmer is a software engineer who primarily develops video games or related software (such as game development tools). Game programming has many specialized disciplines; practitioners of any may regard themselves as "game programmers". A game programmer should not be confused with a game designer; many designers are also programmers, but not all are, and it is rare for one person to serve both roles in modern professional games.[citation needed]

In the early days of video games (from the early 1970s to mid-1980s), a game programmer also took on the job of a designer and artist. This was generally because the abilities of early computers were so limited that having specialized personnel for each function was unnecessary. Game concepts were generally light and games were only meant to be played for a few minutes at a time, but more importantly, art content and variations in gameplay were constrained by computers' limited power.
Later, as specialized arcade hardware and home systems became more powerful, game developers could develop deeper storylines and could include such features as high-resolution and full color graphics, physics, advanced artificial intelligence and digital sound. Technology has advanced to such a great degree that contemporary games usually boast 3D graphics and full motion video using assets developed by professional graphic artists. Nowadays, the derogatory term "programmer art" has come to imply the kind of bright colors and blocky design that was typical of early computer games.
The desire for adding more depth and assets to games necessitated a division of labor. Initially, art production was relegated to fulltime artists. Next game programming became a separate discipline from game design. Now, only some games, such as the puzzle game Bejeweled, are simple enough to require just one fulltime programmer. Despite this division, however, most game developers (artists, programmers and even producers) have some say in the final design of contemporary games.

A contemporary computer game may include advanced physics, artificial intelligence, 3D graphics, digitized sound, an original musical score, complex strategy and may use several input devices (such as mice, keyboards, gamepads and joysticks) and may be playable against other people via the Internet or over a LAN. Each aspect of the game can consume all of one programmer's time and, in many cases, several programmers. Some programmers may specialize in one area of game programming, but many are familiar with several aspects. The number of programmers needed for each feature depends somewhat on programmers' skills, but mostly are dictated by the type of game being developed.


A game's physics programmer is dedicated to developing the physics a game will employ. Typically, a game will only simulate a few aspects of real-world physics. For example, a space game may need simulated gravity, but would not have any need for simulating water viscosity.
Since processing cycles are always at a premium, physics programmers may employ "shortcuts" that are computationally inexpensive, but look and act "good enough" for the game in question. Sometimes, a specific subset of situations is specified and the physical outcome of such situations are stored in a record of some sort and are never computed at runtime at all.
Some physics programmers may even delve into the difficult tasks of inverse kinematics and other motions attributed to game characters, but increasingly these motions are assigned via motion capture libraries so as not to overload the CPU with complex calculations.
For a role-playing game such as Might and Magic, only one physics programmer may be needed. For a complex combat game such as Battlefield 1942, teams of several physics programmers may be required.
See also: dynamical simulation

An AI programmer develops the logic the game uses to carry out a large number of actions. It has recently evolved into a specialized discipline, as these tasks used to be implemented by programmers who specialized in other areas. An AI programmer may program pathfinding, strategy and enemy tactic systems. This is one of the most challenging aspects of game programming and its sophistication is developing rapidly. Contemporary games dedicate approximately 10 to 20 percent of their programming staff to AI, which translates on average to 1 or more dedicated programmers.[1]
Some games, such as strategy games like Civilization III or role-playing games such as The Elder Scrolls IV: Oblivion, use AI heavily, while others, such as puzzle games, use it sparingly or not at all. Many game developers have created entire languages that can be used to program their own AI for games via scripts. These languages are typically less technical than the language used to implement the game, and will often be used by the game or level designers to implement the world of the game. Many studios also make their games' scripting available to players, and it is often used extensively by third party mod developers.
The AI technology used in games programming should not be confused with academic AI programming and research: game programming has little use for developments in this area of study. Although both areas do borrow from each other from time to time, they are usually considered distinct disciplines.

Historically, this title usually belonged to a programmer who developed specialized blitter algorithms and clever optimizations for 2D graphics. Today, however, it is almost exclusively applied to programmers who specialize in developing and modifying complex 3D graphic renderers. Some 2D graphics skills have just recently become useful again, though, for developing games for the new generation of cell phones, PDAs and handheld game consoles.
A 3D graphics programmer must have a firm grasp on advanced mathematical concepts such as vector and matrix math, quaternions and linear algebra.
Programmers specializing in this area of game development can demand high wages and are usually a scarce commodity. Their skills can be used for computer games as well as games for game consoles such as the PlayStation 3, Wii and the Xbox 360.
A 3D graphics programmer may also specialize in a subset of 3D graphics programming, such as pixel shaders or vertex shaders.

Not always a separate discipline, sound programming has been a mainstay of game programming since the days of Pong. Most games make use of audio, and many have a full musical score. Computer audio games eschew graphics altogether and use sound as their primary feedback mechanism.
Many games use advanced techniques such as 3D positional sound, making audio programming a non-trivial matter. With these games, one or two programmers may dedicate all their time to building and refining the game's sound engine, and sound programmers may be trained or have a formal background in digital signal processing.
Scripting tools are often created and/or maintained by sound programmers for use by sound designers. These tools allow designers to associate sounds with characters, actions, objects and events while also assigning music or atmospheric sounds for game environments (levels or areas) and setting environmental variables such as reverberation.

Though all programmers add to the content and experience that a game provides, a gameplay programmer focuses more on a game's strategy and the "feel" of a game. This is usually not a separate discipline, as what this programmer does usually differs from game to game, and they will inevitably be involved with more specialized areas of the game's development such as graphics or sound.
This programmer may implement strategy tables, tweak input code, or adjust other factors that alter the game. Many of these aspects may be altered by programmers who specialize in these areas, however (for example, strategy tables may be implemented by AI programmers).

In early computer games, gameplay programmers would write code to create all the content in the game â€” if the player was supposed to shoot a particular enemy, and a red key was supposed to appear along with some text on the screen, then this functionality was all written as part of the core program in C or assembly language by a gameplay programmer.
More often today the core game engine is usually separated from gameplay programming. This has several development advantages. The game engine deals with graphics rendering, sound, physics and so on while a scripting language deals with things like cinematic events, enemy behavior and game objectives. Large game projects can have a team of scripters to implement these sorts of game content.
Scripters usually are also game designers. It is often easier to find a qualified game designer who can be taught a script language as opposed to finding a qualified game designer who has mastered C++.

This programmer specializes in programming user interfaces (UIs) for games. Though some games have custom user interfaces, this programmer is more likely to develop a library that can be used across multiple projects. Most UIs look 2D, though contemporary UIs usually use the same 3D technology as the rest of the game so some knowledge of 3D math and systems is helpful for this role. Advanced UI systems may allow scripting and special effects, such as transparency, animation or particle effects for the controls.

Input programming, while usually not a job title, or even a full-time position on a particular game project, is still an important task. This programmer writes the code specifying how input devices such as a keyboard, mouse or joystick affect the game. These routines are typically developed early in production and are continually tweaked during development. Normally, one programmer does not need to dedicate his entire time to developing these systems. A first person shooter such as Quake may need a very complex and low latency input system, while the needs of a turn-based strategy game such as Heroes of Might and Magic are much lower.

This programmer writes code that allows players to compete against each other (or play together) connected via a LAN or the Internet (or in rarer cases, directly connected via modem). Programmers implementing this feature of a game can spend all their time on this one task. Network programming is one of the most challenging game programming roles. These programmers have to deal with network latency, packet compression, and dropped or interrupted connections. Though this type of programming can consume the entire development process, network programming is often put off until the last few months of development, adding additional difficulties to this role.

One of the less recognized members of the development team, the tools programmer can make game development heaven or unbearably difficult. Tools are used on almost every game for tasks such as scripting, importing or converting art, modifying behaviors or building levels. Some tools, such as an IDE, 3D graphics modeling software and Photoshop are COTS products, but many tools are specific to the game and are custom programmed.
It is the tools programmer's job to write the tools that handle these game-specific tasks. Some tools will be included with the game, but most will not. Most tools evolve with the game and can easily consume all of several programmers' time. Well written and fairly bug-free tools make everyone's development tasks easier. Poorly written or poorly documented ones can seriously hamper development and jeopardize the project. Due to time constraints, however, many tools are not carefully implemented.

Porting a game from one platform to another has always been an important activity for game developers. Some programmers specialize in this activity, converting code from one operating system to work on another. Sometimes, the programmer is responsible for making the application work not for just one operating system, but on a variety of devices, such as mobile phones. Often, however, "porting" can involve re-writing the entire game from scratch as proprietary languages, tools or hardware make converting source code a fruitless endeavor.
This programmer must be familiar with both the original and target operating systems and languages (for example, converting a game originally written in C++ to Java), convert assets, such as artwork and sounds or rewrite code for low memory phones. This programmer may also have to side-step buggy language implementations, some with little documentation, refactor code, oversee multiple branches of code, rewrite code to scale for wide variety of screen sizes and implement special operator guidelines. They may also have to fix bugs that were not discovered in the original release of a game.

The technology programmer is more likely to be found in larger development studios with specific departments dedicated solely to R&D. Unlike other members of the programming team, the technology programmer usually isn't tied to a specific project or type of development for an extended length of time, and they will typically report directly to a CTO or department head rather than a game producer. As the job title implies, this position is extremely demanding from a technical perspective and requires intimate knowledge of the target platform hardware. Tasks cover a broad range of subjects including the practical implementation of algorithms described in research papers, very low-level assembly optimization and the ability to solve challenging issues pertaining to memory requirements and caching issues during the latter stages of a project. There is considerable amount of cross-over between this position and some of the others, particularly the graphics programmer.

In smaller teams, one or more programmers will often be described as 'Generalists' who will take on the various other roles as needed. Generalists are often engaged in the task of tracking down bugs and determining which subsystem expertise is required to fix them.

The lead programmer is ultimately in charge of all programming for the game. It is their job to make sure the various submodules of the game are being implemented properly and to keep track of development from a programming standpoint. A person in this role usually transitions from other aspects of game programming to this role after several years of experience. Despite the title, this person usually has less time for writing code than other programmers on the project as they are required to attend meetings and interface with the client or other leads on the game. However, the lead programmer is still expected to program at least some of the time and is also expected to be knowledgeable in most technical areas of the game. There is often considerable common ground in the role of technical director and lead programmer, such that the jobs are often covered by one person.

Most game programmers specialize on one platform or another. For example, a programmer can specialize on the PlayStation 3, Xbox 360, Wii or Windows. So, in addition to specializing in one game programming discipline, a programmer may also specialize in development on a certain platform. Therefore, one game programmer's title might be "PlayStation 3 3D Graphics Programmer." Some disciplines, such as AI, are transferable to various platforms and needn't be tailored to one system or another. Also, general game development principles such as 3D graphics programming concepts, sound engineering and user interface design are naturally transferable between platforms.

Notably, there are many game programmers with no formal education in the subject, having started out as hobbyists and doing a great deal of programming on their own, for fun, and eventually succeeding because of their aptitude and homegrown experience. However, most job solicitations for game programmers specify a
